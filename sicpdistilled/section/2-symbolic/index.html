<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8'>
<meta content='IE=edge,chrome=1' http-equiv='X-UA-Compatible'>
<meta content='width=device-width, initial-scale=1' name='viewport'>
<title>SICP Distilled</title>
<link href='http://fonts.googleapis.com/css?family=Droid+Serif' rel='stylesheet' type='text/css'>
<link href="/sicpdistilled/stylesheets/all-e81cfb05.css" rel="stylesheet" />
<script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
<script type='text/x-mathjax-config'>
MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>
</head>
</html>
<body>
<div class='menu--mobile js-mobile-nav' data-target='menu'>Menu</div>
<div class='menu'>
<a href="/sicpdistilled/"><img alt="SICP Distilled" class="logo" src="/sicpdistilled/images/sicp2-07ad7dbe.jpg" />
</a><h1 class='menu__title done'>
<a href="/sicpdistilled/">SICP Distilled
</a></h1>
<ul class='menu__list'>
<li class='done'>
<a href="/sicpdistilled/section/licence"><img alt="CC by-sa" style="border-width: 0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" />
License
</a></li>
<li class='done'>
<a href="#{http_prefix}/section/donate"><img alt="MSF" width="88px" src="/sicpdistilled/images/msf-b09b7038.jpg" />
Donate
</a></li>
</ul>
<h2>Ch1 - Building Abstractions With Functions</h2>
<ul class='menu__list'>
<li class='done'>
<a href="/sicpdistilled/section/1-distilled">Chapter 1 Distilled
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1-intro">Introduction
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1">1.1 - The Elements Of Programming
</a></li>
<ul class='menu__list_2'>
<li class='done'>
<a href="/sicpdistilled/section/1.1.1">Expressions
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.2">Naming and the Environment
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.3">Evaluating Combinations
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.4">Defining New Functions
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.5">The Substitution Model
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1-exercises">Exercises
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.6a">Predicates
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.6b">Conditional Expressions
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.7">Example: Newton’s Method
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.8">Functions as Black-Box Abstractions
</a></li>
</ul>
<li class='done'>
<a href="/sicpdistilled/section/1.2">1.2 - Procedures and the Processes They Generate
</a></li>
<ul class='menu__list_2'>
<li class='done'>
<a href="/sicpdistilled/section/1.2.1">Linear Recursion and Iteration
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.2.2">Tree Recursion
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.2.3">Orders of Growth
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.2.4">Exponentiation
</a></li>
<il class='done'>
<a href="/sicpdistilled/section/1.2.5">Greatest Common Divisors
</a></il>
<li class='done'>
<a href="/sicpdistilled/section/1.2.6">Example: Testing For Primality
</a></li>
</ul>
<li class='done'>
<a href="/sicpdistilled/section/1.3-higher-order">1.3 Higher Order Functions
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/project-blackjack">Project - Blackjack
</a></li>
</ul>
<h2>Ch2 - Building Abstractions With Data</h2>
<ul class='menu__list'>
<li class='done'>
<a href="/sicpdistilled/section/2-distilled">Chapter 2 Distilled
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/2-intro">Introduction
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/2-data-abstraction">Data Abstraction
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/2-nothing">Everything From Nothing
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/2-abstractions">Abstractions In Clojure
</a></li>
<li>
<a href="/sicpdistilled/section/2-data-structures">Clojure's Data Structures
</a></li>
<li>
<a href="/sicpdistilled/section/2-data-abstraction-clj">Data Abstraction, Revisited
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/2-escher">Escher
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/project-escher">Project - Escher
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/2-symbolic">Symbolic Data
</a></li>
<li>
<a href="/sicpdistilled/section/2-sets">Representing Sets
</a></li>
<li>
<a href="/sicpdistilled/section/2-escher">Huffman Encoding Trees
</a></li>
<li>
<a href="/sicpdistilled/section/2-zippers">Zippers
</a></li>
</ul>
<h2>Ch3 - Modularity, Objects, and State</h2>
<h2>Ch4 - Metalinguistic Abstraction</h2>
<ul class='menu__list'>
<li class='done'>
<a href="/sicpdistilled/section/4.1">4.1 - The Metacircular Evaluator
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/halting">The Halting Problem
</a></li>
<li>
<a href="/sicpdistilled/section/y">The Y Combinator
</a></li>
<li>
<a href="/sicpdistilled/section/4.2">4.2 - Lazy Evaluation
</a></li>
<li>
<a href="/sicpdistilled/section/4.3">4.3 - Nondeterministic Computing
</a></li>
<li>
<a href="/sicpdistilled/section/4.4">4.4 - Logic Programming
</a></li>
</ul>
</div>
<div class='container menu--push'>
<h1>Symbolic Data</h1>

<p>All the compound data objects we have used so far were constructed
ultimately from numbers. In this section we extend the
representational capability of our language by introducing the ability
to work with arbitrary symbols as data.</p>

<h2>Quotation</h2>

<p>If we can form compound data using symbols, we can have lists such as</p>

<pre><code class="nohighlight">(a b c d)

(23 45 17)

((Norah 12) (Molly 9) (Anna 7) (Lauren 6) (Charlotte 4))
</code></pre>

<p>Lists containing symbols can look just like the expressions of our
language:</p>

<pre><code class="nohighlight">(* (+ 23 45)

(+ x 9))

(defn fact [n]
  (if (= n 1) 1 (* n (fact (- n 1)))))
</code></pre>

<p>In order to manipulate symbols we need a new element in our language:
the ability to <em>quote</em> a data object. Suppose we want to construct the
list <code>(a b)</code> . We can’t accomplish this with <code>(list a b)</code> , because
this expression constructs a list of the <em>values</em> of a and b rather
than the symbols themselves. This issue is well known in the context
of natural languages, where words and sentences may be regarded either
as semantic entities or as character strings (syntactic entities). The
common practice in natural languages is to use quotation marks to
indicate that a word or a sentence is to be treated literally as a
string of characters. For instance, the first letter of “John” is
clearly “J.” If we tell somebody “say your name aloud,” we expect to
hear that person’s name. However, if we tell somebody “say ‘your name’
aloud,” we expect to hear the words “your name.” Note that we are
forced to nest quotation marks to describe what somebody else might
say.</p>

<p>We can follow this same practice to identify lists and symbols that
are to be treated as data objects rather than as expressions to be
evaluated. However, our format for quoting differs from that of
natural languages in that we place a quotation mark (traditionally,
the single quote symbol <code>&#39;</code>) only at the beginning of the object to be
quoted. We can get away with this in Scheme syntax because we rely on
blanks and parentheses to delimit objects. Thus, the meaning of the
single quote character is to quote the next object</p>

<p>Now we can distinguish between symbols and their values:</p>

<pre><code class="nohighlight">&gt; (def a 1)
&gt; (def b 2)

&gt; (list a b)
(1 2)

&gt; (list &#39;a &#39;b)
(a b)

&gt; (list &#39;a b)
(a 2)
</code></pre>

<p><code>&#39;</code> allows us to type in compound objects, using the
conventional printed representation for lists:</p>

<pre><code class="nohighlight">&gt; (first &#39;(a b c))
a

&gt; (rest &#39;(a b c))
(b c)
</code></pre>

<h2>Reader Macros</h2>

<p>The use of the quotation mark here violates the general rule that all
compound expressions in our language should be delimited by
parentheses and look like lists. We can recover this consistency by
introducing a special form <code>quote</code>, which serves the same purpose as
the quotation mark. Thus, we would type <code>(quote a)</code> instead of <code>&#39;a</code> ,
and we would type <code>(quote (a b c))</code> instead of <code>&#39;(a b c)</code>.</p>

<p>The quotation mark is just a single-character abbreviation for
wrapping the next complete expression with quote to form <code>(quote
⟨exp⟩)</code>.</p>

<p>This is important because it maintains the principle that any
expression seen by the interpreter can be manipulated as a data
object. For instance, we could construct the expression</p>

<pre><code class="nohighlight">(first &#39;(a b c))
</code></pre>

<p>which is the same as</p>

<pre><code class="nohighlight">(first (quote (a b c)))
</code></pre>

<p>by evaluating</p>

<pre><code class="nohighlight">(list &#39;first (list &#39;quote &#39;(a b c)))
</code></pre>

<h2>The Empty List</h2>

<p>We can obtain the empty list by evaluating <code>&#39;()</code>, hence we can do.</p>

<pre><code class="nohighlight">&gt; (cons 1
        (cons 2
              (cons 3 &#39;())))
(1 2 3)
</code></pre>

<h2>Equality</h2>

<p>One additional primitive in Clojure is <code>=</code>, which
takes two arguments and tests whether they are the same.</p>

<p>Using <code>=</code>, we can implement a useful procedure called <code>memq</code>. This
takes two arguments, a symbol and a list. If the symbol is not
contained in the list (i.e., is not = to any item in the list), then
memq returns false. Otherwise, it returns the sublist of the list
beginning with the first occurrence of the symbol:</p>

<pre><code class="nohighlight">(defn memq [item x]
  (cond (empty? x) false
        (= item (first x)) x
        :else (memq item (rest x))))
</code></pre>

<p>For example:</p>

<pre><code class="nohighlight">&gt; (memq &#39;apple &#39;(pear banana prune))
false
</code></pre>

<pre><code class="nohighlight">&gt; (memq &#39;apple &#39;(x (apple sauce) y apple pear))
(apple pear)
</code></pre>

<h3>Exercise 2.53:</h3>

<p>What would the interpreter print in response
to evaluating each of the following expressions?</p>

<pre><code class="nohighlight">(list &#39;a &#39;b &#39;c)

(list (list &#39;george))

(rest &#39;((x1 x2) (y1 y2)))

(list? (first &#39;(a short list)))

(memq &#39;red &#39;((red shoes) (blue socks)))

(memq &#39;red &#39;(red shoes blue socks))
</code></pre>

<h3>Exercise 2.54:</h3>

<p>Two lists are said to be equal? if they contain equal elements
arranged in the same order. For example,</p>

<pre><code>(equal? &#39;(this is a list) &#39;(this is a list))
</code></pre>

<p>is true, but</p>

<pre><code class="nohighlight">(equal? &#39;(this is a list) &#39;(this (is a) list))
</code></pre>

<p>is false. To be more precise, we can define equal? recursively in
terms of the basic <code>=</code> equality of symbols by saying that a and b are
equal? if they are both symbols and the symbols are eq? , or if they
are both lists such that <code>(first a)</code> is <code>equal?</code> to <code>(first b)</code> and <code>(rest
a)</code> is <code>equal?</code> to <code>(rest b)</code> .</p>

<p>Using this idea, implement equal? as a procedure</p>

<h3>Exercise 2.55</h3>

<p>Eva Lu Ator types to the interpreter the expression</p>

<pre><code class="nohighlight">(first &#39;&#39;abracadabra)
</code></pre>

<p>To her surprise, the interpreter prints back <code>quote</code> why?</p>

</div>
<script src='https://cdn.polyfill.io/v1/polyfill.min.js'></script>
<script src="/sicpdistilled/javascripts/all-0c20c227.js"></script>
<link href='http://app.klipse.tech/css/codemirror.css' rel='stylesheet' type='text/css'>
<script>
  window.klipse_settings = {
    selector: 'code.clojure'
  };
</script>
<script src='http://app.klipse.tech/dev/js/klipse_plugin.js'></script>
</body>
