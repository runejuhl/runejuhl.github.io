<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8'>
<meta content='IE=edge,chrome=1' http-equiv='X-UA-Compatible'>
<meta content='width=device-width; initial-scale=1' name='viewport'>
<title>SICP Distilled</title>
<link href='http://fonts.googleapis.com/css?family=Droid+Serif' rel='stylesheet' type='text/css'>
<link href="/sicpdistilled/stylesheets/all-e81cfb05.css" rel="stylesheet" />
<script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
<script type='text/x-mathjax-config'>
MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>
</head>
</html>
<body>
<div class='menu--mobile js-mobile-nav' data-target='menu'>Menu</div>
<div class='menu'>
<a href='/'>
<img alt='SICP Distilled' class='logo' src='/sicpdistilled/images/sicp2-07ad7dbe.jpg'>
</a>
<h1 class='menu__title done'>
<a href='/'>
SICP Distilled
</a>
</h1>
<ul class='menu__list'>
<li class='done'>
<a href='/sicpdistilled/section/licence'>
<img alt='CC by-sa' src='https://i.creativecommons.org/l/by-sa/4.0/88x31.png' style='border-width:0'>
Licence
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/donate'>
<img alt='MSF ' src='/sicpdistilled/images/msf-b09b7038.jpg' style='border-width:0' width='88px'>
Donate
</a>
</li>
</ul>
<h2>Ch1 - Building Abstractions With Functions</h2>
<ul class='menu__list'>
<li class='done'>
<a href='/sicpdistilled/section/1-distilled'>
Chapter 1 Distilled
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1-intro'>
Introduction
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1'>
1.1 - The Elements Of Programming
</a>
</li>
<ul class='menu__list_2'>
<li class='done'>
<a href='/sicpdistilled/section/1.1.1'>
Expressions
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.2'>
Naming and the Environment
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.3'>
Evaluating Combinations
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.4'>
Defining New Functions
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.5'>
The Substitution Model
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1-exercises'>
Exercises
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.6a'>
Predicates
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.6b'>
Conditional Expressions
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.7'>
Example: Newton’s Method
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.8'>
Functions as Black-Box Abstractions
</a>
</li>
</ul>
<li class='done'>
<a href='/sicpdistilled/section/1.2'>
1.2 - Procedures and the Processes They Generate
</a>
</li>
<ul class='menu__list_2'>
<li class='done'>
<a href='/sicpdistilled/section/1.2.1'>
Linear Recursion and Iteration
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.2.2'>
Tree Recursion
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.2.3'>
Orders of Growth
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.2.4'>
Exponentiation
</a>
</li>
<il class='done'>
<a href='/sicpdistilled/section/1.2.5'>
Greatest Common Divisors
</a>
</il>
<li class='done'>
<a href='/sicpdistilled/section/1.2.6'>
Example: Testing For Primality
</a>
</li>
</ul>
<li class='done'>
<a href='/sicpdistilled/section/1.3-higher-order'>
1.3 Higher Order Functions
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/project-blackjack'>
Project - Blackjack
</a>
</li>
</ul>
<h2>Ch2 - Building Abstractions With Data</h2>
<ul class='menu__list'>
<li class='done'>
<a href='/sicpdistilled/section/2-distilled'>
Chapter 2 Distilled
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/2-intro'>
Introduction
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/2-data-abstraction'>
Data Abstraction
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/2-nothing'>
Everything From Nothing
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/2-abstractions'>
Abstractions In Clojure
</a>
</li>
<li>
<a href='/sicpdistilled/section/2-data-structures'>
Clojure's Data Structures
</a>
</li>
<li>
<a href='/sicpdistilled/section/2-data-abstraction-clj'>
Data Abstraction, Revisited
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/2-escher'>
Escher
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/project-escher'>
Project - Escher
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/2-symbolic'>
Symbolic Data
</a>
</li>
<li>
<a href='/sicpdistilled/section/2-sets'>
Representing Sets
</a>
</li>
<li>
<a href='/sicpdistilled/section/2-escher'>
Huffman Encoding Trees
</a>
</li>
<li>
<a href='/sicpdistilled/section/2-zippers'>
Zippers
</a>
</li>
</ul>
<h2>Ch3 - Modularity, Objects, and State</h2>
<h2>Ch4 - Metalinguistic Abstraction</h2>
<ul class='menu__list'>
<li class='done'>
<a href='/sicpdistilled/section/4.1'>
4.1 - The Metacircular Evaluator
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/halting'>
The Halting Problem
</a>
</li>
<li>
<a href='/sicpdistilled/section/y'>
The Y Combinator
</a>
</li>
<li>
<a href='/sicpdistilled/section/4.2'>
4.2 - Lazy Evaluation
</a>
</li>
<li>
<a href='/sicpdistilled/section/4.3'>
4.3 - Nondeterministic Computing
</a>
</li>
<li>
<a href='/sicpdistilled/section/4.4'>
4.4 - Logic Programming
</a>
</li>
</ul>
</div>
<div class='container menu--push'>
<h1>What Is Meant by Data?</h1>

<p>We began the rational-number implementation in
<a href="/sicpdistilled/section/2-data-abstraction">earlier</a> by implementing the
rational-number operations <code>add-rat</code>, <code>sub-rat</code> and so on in terms of
three unspecified functions: <code>make-rat</code>, <code>numer</code>, and <code>denom</code>.  At
that point, we could think of the operations as being defined in terms
of data objects - numerators, denominators, and rational numbers -
whose behavior was specified by the latter three functions.</p>

<p>But exactly what is meant by data? It is not enough to say “whatever
is implemented by the given selectors and constructors.” Clearly, not
every arbitrary set of three functions can serve as an appropriate
basis for the rational-number implementation. We need to guarantee
that, if we construct a rational number x from a pair of integers n
and d , then extracting the <code>numer</code> and the <code>denom</code> of <code>x</code> and
dividing them should yield the same result as dividing <code>n</code> by <code>d</code>. In
other words, <code>make-rat</code>, <code>numer</code>, and <code>denom</code> must satisfy the
condition that, for any integer n and any non-zero integer <code>d</code>, if <code>x</code>
is <code>(make-rat n d)</code>, then:</p>

<pre><code class="clojure">&gt; (= (/ (numer x)
        (demom y))
     (/ n d))
true
</code></pre>

<p>In fact, this is the only condition <code>make-rat</code>, <code>numer</code>, and <code>denom</code>
must fulfill in order to form a suitable basis for a rational-number
representation.  In general, we can think of data as defined by some
collection of selectors and constructors, together with specified
conditions that these functions must fulfill in order to be a valid
representation <sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup></p>

<p>This point of view can serve to define not only “high-level” data
objects, such as rational numbers, but lower-level objects as
well.</p>

<h1>Everything From (Almost) Nothing</h1>

<p>Consider the notion of a pair, which we used in order to define our
rational numbers. We never actually said what a pair was, only that
the language supplied functions cons , car , and cdr for operating on
pairs. But the only thing we need to know about these three operations
is that if we glue two objects together using cons we can retrieve the
objects using car and cdr . That is, the operations satisfy the
condition that, for any objects <code>x</code> and <code>y</code>, if <code>z</code> is <code>(cons x y)</code>
then <code>(car z)</code>is x and <code>(cdr z)</code> is y .</p>

<p>Indeed, we imagined that these three functions are included as
primitives in our language. However, any triple of functions that
satisfies the above condition can be used as the basis for
implementing pairs.  This point is illustrated strikingly by the fact
that we could implement <code>cons</code> , <code>car</code> , and <code>cdr</code> without using any
data structures at all but only using functions.</p>

<p>Here are the definitions:</p>

<pre><code class="clojure">(defn cons [x y]
  (fn [m]
    (cond (= m 0) x
          (= m 1) y)))

(defn car [z]
  (z 0))

(defn cdr [z]
  (z 1))
</code></pre>

<p>This use of functions corresponds to nothing like our intuitive
notion of what data should be. Nevertheless, all we need to do to show
that this is a valid way to represent pairs is to verify that these
functions satisfy the condition given above.</p>

<p>The subtle point to notice is that the value returned by <code>(cons x y)</code>
is a function, which takes one argument and returns either <code>x</code> or <code>y</code>
depending on whether the argument is <code>0</code> or <code>1</code>. Correspondingly,
<code>(car z)</code> is defined to apply <code>z</code> to <code>0</code>. Hence, if <code>z</code> is the
function formed by <code>(cons x y)</code>, then <code>z</code> applied to <code>0</code> will yield
<code>x</code> . Thus, we have shown that <code>(car (cons x y))</code> yields <code>x</code>, as
desired. Similarly, <code>(cdr (cons x y))</code> applies the function returned
by <code>(cons x y)</code> to <code>1</code>, which returns <code>y</code>. Therefore, this functional
implementation of pairs is a valid implementation, and if we access
pairs using only <code>cons</code>, <code>car</code>, and <code>cdr</code> we cannot distinguish this
implementation from one that uses “real” data structures.</p>

<p>The point of exhibiting the functional representation of pairs is not
that our language works this way (Scheme, Clojure, and Lisp systems in
general, implement pairs directly, for efficiency reasons) but that it
could work this way. The functional representation, although obscure,
is a perfectly adequate way to represent pairs, since it fulfills the
only conditions that pairs need to fulfill. This example also
demonstrates that the ability to manipulate functions as objects
automatically provides the ability to represent compound data. This
may seem a curiosity now, but procedu- ral representations of data
will play a central role in our programming repertoire.</p>

<h1>Numbers from functions</h1>

<p>In case representing pairs as functions wasn’t mind-boggling enough,
consider that, in a language that can manipulate functions, we can get
by without numbers (at least insofar as nonnegative integers are
concerned) by implementing <code>0</code> and the operation of adding <code>1</code> as</p>

<pre><code class="clojure">(def zero (fn [f] (fn [x] x)))

(defn inc [n]
  (fn [f] (fn [x] (f ((n f) x)))))
</code></pre>

<p>Can you figure out what one and two would be?  (use substitution to
evaluate <code>(inc zero)</code>)</p>

<p>This representation is known as
<a href="https://en.wikipedia.org/wiki/Church_encoding#Church_numerals">Church Numerals</a>,
after its inventor, Alonzo Church, the logician who invented the
λ-calculus, and you will have lots of fun using them in the
<a href="/project-numbers">project</a></p>

<p>So in Chapter One we looked at functions of numbers, we then
introduced data structures and saw that we could create them from
functions, lastly we created numbers from functions. I&#39;d say that was
pretty magic.</p>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p>Surprisingly, this idea is very difficult to formulate
rigorously. There are two approaches to giving such a formulation. One,
pioneered by C. A. R. Hoare (1972), is known as the method of abstract
models . It formalizes the “functions plus conditions” specification
as outlined in the rational-number example above. Note that the
condition on the rational-number representation was stated in terms of
facts about integers (equality and division). In general, abstract
models define new kinds of data objects in terms of previously defined
types of data objects. Assertions about data objects can therefore be
checked by reducing them to assertions about previously defined data
objects. Another approach, introduced by Zilles at MIT, by Goguen,
Thatcher, Wagner, and Wright at IBM (see Thatcher et al. 1978), and by
Guttag at Toronto (see Guttag 1977), is called algebraic specification
. It regards the “functions” as elements of an abstract algebraic
system whose behavior is specified by axioms that correspond to our
“conditions,” and uses the techniques of abstract algebra to check
assertions about data objects. Both methods are surveyed in the paper
by Liskov and Zilles (1975).&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

</div>
<script src='https://cdn.polyfill.io/v1/polyfill.min.js'></script>
<script src="/sicpdistilled/javascripts/all-0c20c227.js"></script>
</body>
