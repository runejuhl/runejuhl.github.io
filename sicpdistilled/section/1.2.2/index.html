<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8'>
<meta content='IE=edge,chrome=1' http-equiv='X-UA-Compatible'>
<meta content='width=device-width, initial-scale=1' name='viewport'>
<title>SICP Distilled</title>
<link href='http://fonts.googleapis.com/css?family=Droid+Serif' rel='stylesheet' type='text/css'>
<link href="/sicpdistilled/stylesheets/all-e81cfb05.css" rel="stylesheet" />
<script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
<script type='text/x-mathjax-config'>
MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>
</head>
</html>
<body>
<div class='menu--mobile js-mobile-nav' data-target='menu'>Menu</div>
<div class='menu'>
<a href="/sicpdistilled/"><img alt="SICP Distilled" class="logo" src="/sicpdistilled/images/sicp2-07ad7dbe.jpg" />
</a><h1 class='menu__title done'>
<a href="/sicpdistilled/">SICP Distilled
</a></h1>
<ul class='menu__list'>
<li class='done'>
<a href="/sicpdistilled/section/licence"><img alt="CC by-sa" style="border-width: 0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" />
License
</a></li>
<li class='done'>
<a href="#{http_prefix}/section/donate"><img alt="MSF" width="88px" src="/sicpdistilled/images/msf-b09b7038.jpg" />
Donate
</a></li>
</ul>
<h2>Ch1 - Building Abstractions With Functions</h2>
<ul class='menu__list'>
<li class='done'>
<a href="/sicpdistilled/section/1-distilled">Chapter 1 Distilled
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1-intro">Introduction
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1">1.1 - The Elements Of Programming
</a></li>
<ul class='menu__list_2'>
<li class='done'>
<a href="/sicpdistilled/section/1.1.1">Expressions
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.2">Naming and the Environment
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.3">Evaluating Combinations
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.4">Defining New Functions
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.5">The Substitution Model
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1-exercises">Exercises
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.6a">Predicates
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.6b">Conditional Expressions
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.7">Example: Newton’s Method
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.8">Functions as Black-Box Abstractions
</a></li>
</ul>
<li class='done'>
<a href="/sicpdistilled/section/1.2">1.2 - Procedures and the Processes They Generate
</a></li>
<ul class='menu__list_2'>
<li class='done'>
<a href="/sicpdistilled/section/1.2.1">Linear Recursion and Iteration
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.2.2">Tree Recursion
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.2.3">Orders of Growth
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.2.4">Exponentiation
</a></li>
<il class='done'>
<a href="/sicpdistilled/section/1.2.5">Greatest Common Divisors
</a></il>
<li class='done'>
<a href="/sicpdistilled/section/1.2.6">Example: Testing For Primality
</a></li>
</ul>
<li class='done'>
<a href="/sicpdistilled/section/1.3-higher-order">1.3 Higher Order Functions
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/project-blackjack">Project - Blackjack
</a></li>
</ul>
<h2>Ch2 - Building Abstractions With Data</h2>
<ul class='menu__list'>
<li class='done'>
<a href="/sicpdistilled/section/2-distilled">Chapter 2 Distilled
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/2-intro">Introduction
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/2-data-abstraction">Data Abstraction
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/2-nothing">Everything From Nothing
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/2-abstractions">Abstractions In Clojure
</a></li>
<li>
<a href="/sicpdistilled/section/2-data-structures">Clojure's Data Structures
</a></li>
<li>
<a href="/sicpdistilled/section/2-data-abstraction-clj">Data Abstraction, Revisited
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/2-escher">Escher
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/project-escher">Project - Escher
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/2-symbolic">Symbolic Data
</a></li>
<li>
<a href="/sicpdistilled/section/2-sets">Representing Sets
</a></li>
<li>
<a href="/sicpdistilled/section/2-escher">Huffman Encoding Trees
</a></li>
<li>
<a href="/sicpdistilled/section/2-zippers">Zippers
</a></li>
</ul>
<h2>Ch3 - Modularity, Objects, and State</h2>
<h2>Ch4 - Metalinguistic Abstraction</h2>
<ul class='menu__list'>
<li class='done'>
<a href="/sicpdistilled/section/4.1">4.1 - The Metacircular Evaluator
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/halting">The Halting Problem
</a></li>
<li>
<a href="/sicpdistilled/section/y">The Y Combinator
</a></li>
<li>
<a href="/sicpdistilled/section/4.2">4.2 - Lazy Evaluation
</a></li>
<li>
<a href="/sicpdistilled/section/4.3">4.3 - Nondeterministic Computing
</a></li>
<li>
<a href="/sicpdistilled/section/4.4">4.4 - Logic Programming
</a></li>
</ul>
</div>
<div class='container menu--push'>
<h1>Tree Recursion</h1>

<p>Another common pattern of computation is called tree recursion . As an
example, consider computing the sequence of Fibonacci numbers, in
which each number is the sum of the preceding two:</p>

<p>$$
0, 1, 2, 3, 5, 8, 13, 21 \dots
$$</p>

<p>In general, the Fibonacci numbers can be defined by the rule</p>

<p><img width="100%" src="/sicpdistilled/images/fibdef-9a85d5e8.png" /></p>

<p>We can immediately translate this definition into a recursive procedure
for computing Fibonacci numbers:</p>

<pre><code class="clojure">(defn fib [n]
  (cond (= n 0) 0
        (= n 1) 1
        :else (+ (fib (- n 1))
                 (fib (- n 2)))))
</code></pre>

<p>Consider the pattern of this computation. To compute <code>(fib 5)</code> , we
compute <code>(fib 4)</code> and <code>(fib 3)</code> . To compute <code>(fib 4)</code> , we compute
<code>(fib 3)</code> and <code>(fib 2)</code> . In general, the evolved process looks like a
tree, as shown in Figure 1.5. Notice that the branches split into two
at each level (except at the bottom); this reflects the fact that the
<code>fib</code> procedure calls itself twice each time it is invoked.</p>

<p>This procedure is instructive as a prototypical tree recursion, but it
is a terrible way to compute Fibonacci numbers because it does so much
redundant computation. Notice below that the entire computation of
<code>(fib 3)</code>, almost half the work, is duplicated. In fact, it is not
hard to show that the number of times the procedure will compute <code>(fib
1)</code> or <code>(fib 0)</code> (the number of leaves in the above tree, in general)
is precisely <code>Fib(n + 1)</code>. To get an idea of how bad this is, one can
show that the value of <code>Fib(n)</code> grows exponentially with <code>n</code></p>

<p><img width="100%" src="/sicpdistilled/images/fib5-c4308cf0.png" /></p>

<p>Thus, the process uses a number of steps that grows exponentially with
the input. On the other hand, the space required grows only linearly
with the input, because we need keep track only of which nodes are
above us in the tree at any point in the computation. In general, the
number of steps required by a tree-recursive process will be
proportional to the number of nodes in the tree, while the space
required will be proportional to the maximum depth of the tree.  We
can also formulate an iterative process for computing the Fibonacci
numbers. The idea is to use a pair of integers a and b, initialized to
<code>Fib(1) = 1</code> and <code>Fib(0) = 0</code>, and to repeatedly apply the
simultaneous transformations</p>

<p>$$ a \leftarrow a+b $$
$$ b \leftarrow a $$</p>

<p>It is not hard to show that, aer applying this transformation <code>n</code>
times, <code>a</code> and <code>b</code> will be equal, respectively, to <code>Fib(n + 1)</code> and
<code>Fib(n)</code>. Thus, we can compute Fibonacci numbers iteratively using the
procedure</p>

<pre><code class="clojure">(defn fib [n]
  (fib-iter 1 0 n))

(defn- fib-iter [a b count]
  (if (= count 0)
      b
      (fib-iter (+ a b) a (- count 1))))
</code></pre>

<p>This second method for computing <code>fib(n)</code> is a linear iteration. The
difference in number of steps required by the two methods—one linear
in n, one growing as fast as <code>fib(n</code>) itself—is enormous, even for
small inputs.</p>

<p>One should not conclude from this that tree-recursive processes are
useless. When we consider processes that operate on hierarchically
structured data rather than numbers, we will find that tree recursion
is a natural and powerful tool (the interpretation process itself is
recursive in this way). But even in numerical operations, tree
recursive processes can be useful in helping us to understand and
design programs. For instance, although the first fib procedure is
much less efficient than the second one, it is more straightforward,
being little more than a translation into Lisp of the definition of
the Fibonacci sequence. To formulate the iterative algorithm required
noticing that the computation could be recast as an iteration with
three state variables.</p>

<p>One approach to coping with redundant computations is to arrange
matters so that we automatically construct a table of values as they
are computed.  Each time we are asked to apply the procedure to some
argument, we first look to see if the value is already stored in the
table, in which case we avoid performing the redundant
computation. This strategy, known as tabulation or memoization , can
be implemented in a straightforward way. Tabulation can sometimes be
used to transform processes that require an exponential number of
steps into processes whose space and time requirements grow linearly
with the input.</p>

<h1>Ex 1.11</h1>

<p>A function f is defined by the rule that</p>

<p><img width="100%" src="/sicpdistilled/images/ex1.11-619ebf57.png" /></p>

<p>Write a procedure that computes f by means of</p>

<ul>
<li>a recursive process</li>
<li>an iterative process</li>
</ul>

</div>
<script src='https://cdn.polyfill.io/v1/polyfill.min.js'></script>
<script src="/sicpdistilled/javascripts/all-0c20c227.js"></script>
<link href='http://app.klipse.tech/css/codemirror.css' rel='stylesheet' type='text/css'>
<script>
  window.klipse_settings = {
    selector: 'code.clojure'
  };
</script>
<script src='http://app.klipse.tech/dev/js/klipse_plugin.js'></script>
</body>
