<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8'>
<meta content='IE=edge,chrome=1' http-equiv='X-UA-Compatible'>
<meta content='width=device-width, initial-scale=1' name='viewport'>
<title>SICP Distilled</title>
<link href='http://fonts.googleapis.com/css?family=Droid+Serif' rel='stylesheet' type='text/css'>
<link href="/sicpdistilled/stylesheets/all-e81cfb05.css" rel="stylesheet" />
<script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
<script type='text/x-mathjax-config'>
MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>
</head>
</html>
<body>
<div class='menu--mobile js-mobile-nav' data-target='menu'>Menu</div>
<div class='menu'>
<a href="/sicpdistilled/"><img alt="SICP Distilled" class="logo" src="/sicpdistilled/images/sicp2-07ad7dbe.jpg" />
</a><h1 class='menu__title done'>
<a href="/sicpdistilled/">SICP Distilled
</a></h1>
<ul class='menu__list'>
<li class='done'>
<a href="/sicpdistilled/section/licence"><img alt="CC by-sa" style="border-width: 0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" />
License
</a></li>
<li class='done'>
<a href="#{http_prefix}/section/donate"><img alt="MSF" width="88px" src="/sicpdistilled/images/msf-b09b7038.jpg" />
Donate
</a></li>
</ul>
<h2>Ch1 - Building Abstractions With Functions</h2>
<ul class='menu__list'>
<li class='done'>
<a href="/sicpdistilled/section/1-distilled">Chapter 1 Distilled
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1-intro">Introduction
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1">1.1 - The Elements Of Programming
</a></li>
<ul class='menu__list_2'>
<li class='done'>
<a href="/sicpdistilled/section/1.1.1">Expressions
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.2">Naming and the Environment
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.3">Evaluating Combinations
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.4">Defining New Functions
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.5">The Substitution Model
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1-exercises">Exercises
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.6a">Predicates
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.6b">Conditional Expressions
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.7">Example: Newtonâ€™s Method
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.8">Functions as Black-Box Abstractions
</a></li>
</ul>
<li class='done'>
<a href="/sicpdistilled/section/1.2">1.2 - Procedures and the Processes They Generate
</a></li>
<ul class='menu__list_2'>
<li class='done'>
<a href="/sicpdistilled/section/1.2.1">Linear Recursion and Iteration
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.2.2">Tree Recursion
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.2.3">Orders of Growth
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.2.4">Exponentiation
</a></li>
<il class='done'>
<a href="/sicpdistilled/section/1.2.5">Greatest Common Divisors
</a></il>
<li class='done'>
<a href="/sicpdistilled/section/1.2.6">Example: Testing For Primality
</a></li>
</ul>
<li class='done'>
<a href="/sicpdistilled/section/1.3-higher-order">1.3 Higher Order Functions
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/project-blackjack">Project - Blackjack
</a></li>
</ul>
<h2>Ch2 - Building Abstractions With Data</h2>
<ul class='menu__list'>
<li class='done'>
<a href="/sicpdistilled/section/2-distilled">Chapter 2 Distilled
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/2-intro">Introduction
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/2-data-abstraction">Data Abstraction
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/2-nothing">Everything From Nothing
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/2-abstractions">Abstractions In Clojure
</a></li>
<li>
<a href="/sicpdistilled/section/2-data-structures">Clojure's Data Structures
</a></li>
<li>
<a href="/sicpdistilled/section/2-data-abstraction-clj">Data Abstraction, Revisited
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/2-escher">Escher
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/project-escher">Project - Escher
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/2-symbolic">Symbolic Data
</a></li>
<li>
<a href="/sicpdistilled/section/2-sets">Representing Sets
</a></li>
<li>
<a href="/sicpdistilled/section/2-escher">Huffman Encoding Trees
</a></li>
<li>
<a href="/sicpdistilled/section/2-zippers">Zippers
</a></li>
</ul>
<h2>Ch3 - Modularity, Objects, and State</h2>
<h2>Ch4 - Metalinguistic Abstraction</h2>
<ul class='menu__list'>
<li class='done'>
<a href="/sicpdistilled/section/4.1">4.1 - The Metacircular Evaluator
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/halting">The Halting Problem
</a></li>
<li>
<a href="/sicpdistilled/section/y">The Y Combinator
</a></li>
<li>
<a href="/sicpdistilled/section/4.2">4.2 - Lazy Evaluation
</a></li>
<li>
<a href="/sicpdistilled/section/4.3">4.3 - Nondeterministic Computing
</a></li>
<li>
<a href="/sicpdistilled/section/4.4">4.4 - Logic Programming
</a></li>
</ul>
</div>
<div class='container menu--push'>
<h1>The REPL</h1>

<p>LISPs all have a so-called Read-Eval-Print-Loop where you type an expression and
the interpreter responds by displaying the result of its evaluating that
expression.</p>

<h2>Try Clojure</h2>

<p>You can use <a href="http://www.tryclj.com/">Try Clojure</a> to get a REPL (you may also
like to do the intro there, start it by typing <code>next</code>)</p>

<h2>Leiningen</h2>

<p>Leiningen is the easiest way to manage Clojure projects, it also provides a repl</p>

<p>Run <code>lein repl</code> from the commandline after you have
<a href="http://leiningen.org/">installed Leiningen</a></p>

<h1>Primitive expressions</h1>

<h2>Self-evaluating expressions</h2>

<p>Some things simply evaluate to themselves:</p>

<h3>Numbers</h3>

<pre><code class="clojure">&gt; 3
3
</code></pre>

<h3>Strings</h3>

<pre><code class="clojure">&gt; &quot;Hello&quot;
&quot;Hello&quot;
</code></pre>

<h3>Keywords</h3>

<pre><code class="clojure">&gt; :foo
:foo
</code></pre>

<h3>Booleans</h3>

<pre><code class="clojure">&gt; true
true

&gt; false
false
</code></pre>

<h3>Chars</h3>

<pre><code class="clojure">&gt; \c
\c
</code></pre>

<h3>Unbound variables</h3>

<p>If you try to lookup a name that does not exist then you get an error</p>

<pre><code class="clojure">&gt; undefined
CompilerException java.lang.RuntimeException:
  Unable to resolve symbol: undefined in this context
</code></pre>

<h1>Compound elements</h1>

<pre><code class="clojure">&gt; (+ 2 4)
6
</code></pre>

<p>Expressions such as these, formed by delimiting a list of expressions within
parentheses in order to denote function application, are called <em>combinations</em>.
The leftmost element in the list is called the <em>operator</em>, and the other elements
are called <em>operands</em>. The value of a combination is obtained by applying the
function specified by the operator to the arguments that are the values of the
operands.</p>

<p>The convention of placing the operator to the left of the operands is known as
prefix notation, and it may be somewhat confusing at first because it departs
significantly from the customary mathematical convention. Prefix notation has
several advantages, however. One of them is that it can accommodate functions
that may take an arbitrary number of arguments, as in the following examples:</p>

<pre><code class="clojure">&gt; (* 2 3 4)
24
</code></pre>

<pre><code class="clojure">&gt; (/ 45 5 3)
3
</code></pre>

<h2>Nesting</h2>

<p>Prefix notation also extends in a straightforward way to allow combinations to
be nested, that is, to have combinations whose elements are themselves
combinations:</p>

<pre><code class="clojure">&gt; (+ (* 3 5) (- 10 6))
19
</code></pre>

<h2>Pretty Printing</h2>

<p>Sometimes reading complex s-expressions can be made easier by lining them up</p>

<pre><code class="clojure">(+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))
</code></pre>

<pre><code class="clojure">(+ (* 3
      (+ (* 2 4)
         (+ 3 5)))
   (+ (- 10 7)
      6))
</code></pre>

</div>
<script src='https://cdn.polyfill.io/v1/polyfill.min.js'></script>
<script src="/sicpdistilled/javascripts/all-0c20c227.js"></script>
<link href='http://app.klipse.tech/css/codemirror.css' rel='stylesheet' type='text/css'>
<script>
  window.klipse_settings = {
    selector: 'code.clojure'
  };
</script>
<script src='http://app.klipse.tech/dev/js/klipse_plugin.js'></script>
</body>
