<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8'>
<meta content='IE=edge,chrome=1' http-equiv='X-UA-Compatible'>
<meta content='width=device-width, initial-scale=1' name='viewport'>
<title>SICP Distilled</title>
<link href='http://fonts.googleapis.com/css?family=Droid+Serif' rel='stylesheet' type='text/css'>
<link href="/sicpdistilled/stylesheets/all-e81cfb05.css" rel="stylesheet" />
<script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
<script type='text/x-mathjax-config'>
MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>
</head>
</html>
<body>
<div class='menu--mobile js-mobile-nav' data-target='menu'>Menu</div>
<div class='menu'>
<a href="/sicpdistilled/"><img alt="SICP Distilled" class="logo" src="/sicpdistilled/images/sicp2-07ad7dbe.jpg" />
</a><h1 class='menu__title done'>
<a href="/sicpdistilled/">SICP Distilled
</a></h1>
<ul class='menu__list'>
<li class='done'>
<a href="/sicpdistilled/section/licence"><img alt="CC by-sa" style="border-width: 0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" />
License
</a></li>
<li class='done'>
<a href="#{http_prefix}/section/donate"><img alt="MSF" width="88px" src="/sicpdistilled/images/msf-b09b7038.jpg" />
Donate
</a></li>
</ul>
<h2>Ch1 - Building Abstractions With Functions</h2>
<ul class='menu__list'>
<li class='done'>
<a href="/sicpdistilled/section/1-distilled">Chapter 1 Distilled
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1-intro">Introduction
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1">1.1 - The Elements Of Programming
</a></li>
<ul class='menu__list_2'>
<li class='done'>
<a href="/sicpdistilled/section/1.1.1">Expressions
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.2">Naming and the Environment
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.3">Evaluating Combinations
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.4">Defining New Functions
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.5">The Substitution Model
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1-exercises">Exercises
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.6a">Predicates
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.6b">Conditional Expressions
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.7">Example: Newton’s Method
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.8">Functions as Black-Box Abstractions
</a></li>
</ul>
<li class='done'>
<a href="/sicpdistilled/section/1.2">1.2 - Procedures and the Processes They Generate
</a></li>
<ul class='menu__list_2'>
<li class='done'>
<a href="/sicpdistilled/section/1.2.1">Linear Recursion and Iteration
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.2.2">Tree Recursion
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.2.3">Orders of Growth
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.2.4">Exponentiation
</a></li>
<il class='done'>
<a href="/sicpdistilled/section/1.2.5">Greatest Common Divisors
</a></il>
<li class='done'>
<a href="/sicpdistilled/section/1.2.6">Example: Testing For Primality
</a></li>
</ul>
<li class='done'>
<a href="/sicpdistilled/section/1.3-higher-order">1.3 Higher Order Functions
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/project-blackjack">Project - Blackjack
</a></li>
</ul>
<h2>Ch2 - Building Abstractions With Data</h2>
<ul class='menu__list'>
<li class='done'>
<a href="/sicpdistilled/section/2-distilled">Chapter 2 Distilled
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/2-intro">Introduction
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/2-data-abstraction">Data Abstraction
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/2-nothing">Everything From Nothing
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/2-abstractions">Abstractions In Clojure
</a></li>
<li>
<a href="/sicpdistilled/section/2-data-structures">Clojure's Data Structures
</a></li>
<li>
<a href="/sicpdistilled/section/2-data-abstraction-clj">Data Abstraction, Revisited
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/2-escher">Escher
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/project-escher">Project - Escher
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/2-symbolic">Symbolic Data
</a></li>
<li>
<a href="/sicpdistilled/section/2-sets">Representing Sets
</a></li>
<li>
<a href="/sicpdistilled/section/2-escher">Huffman Encoding Trees
</a></li>
<li>
<a href="/sicpdistilled/section/2-zippers">Zippers
</a></li>
</ul>
<h2>Ch3 - Modularity, Objects, and State</h2>
<h2>Ch4 - Metalinguistic Abstraction</h2>
<ul class='menu__list'>
<li class='done'>
<a href="/sicpdistilled/section/4.1">4.1 - The Metacircular Evaluator
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/halting">The Halting Problem
</a></li>
<li>
<a href="/sicpdistilled/section/y">The Y Combinator
</a></li>
<li>
<a href="/sicpdistilled/section/4.2">4.2 - Lazy Evaluation
</a></li>
<li>
<a href="/sicpdistilled/section/4.3">4.3 - Nondeterministic Computing
</a></li>
<li>
<a href="/sicpdistilled/section/4.4">4.4 - Logic Programming
</a></li>
</ul>
</div>
<div class='container menu--push'>
<h1>Building Abstractions with Data</h1>

<blockquote>We now come to the decisive step of mathematical
abstraction: we forget about what the symbols stand
for. . . .[The mathematician] need not be idle; there are many
operations which he may carry out with these symbols, without ever
having to look at the things they stand for.  <cite>Hermann Weyl, The
Mathematical Way of Thinking</cite></blockquote>

<p>We concentrated in Chapter 1 on computational processes and on the
role of functions in program design. We saw how to use primitive data
(numbers) and primitive operations (arithmetic operations), how to
combine functions to create our own functions through composition,
conditionals, and the use of parameters, and how to abstract functions
by using <code>defn</code> . We saw that a function can be regarded as a pattern
for the local evolution of a process, and we classified, reasoned
about, and performed simple algorithmic analyses of some common
patterns for processes as embodied in functions. We also saw that
higher-order functions enhance the power of our language by enabling
us to manipulate, and thereby to reason in terms of, general methods
of computation. This is much of the essence of programming.</p>

<p>In this chapter we are going to look at more complex data. All the
functions in chapter 1 operate on simple numerical data, and simple
data are not sufficient for many of the problems we wish to address
using computation. Programs are typically designed to model complex
phenomena, and more often than not one must construct computational
objects that have several parts in order to model real-world phenomena
that have several aspects. Thus, whereas our focus in chapter 1 was on
building abstractions by combining functions and creating our own, we
turn in this chapter to another key aspect of any programming
language: the means it provides for building abstractions by combining
data objects to form <em>compound data</em>.</p>

<p>Why do we want compound data in a programming language? For the same
reasons that we want to create our own functions: to elevate the
conceptual level at which we can design our programs, to increase the
modularity of our designs, and to enhance the expressive power of our
language. Just as the ability to create functions enables us to deal
with processes at a higher conceptual level than that of the primitive
operations of the language, the ability to construct compound data
objects enables us to deal with data at a higher conceptual level than
that of the primitive data objects of the language.</p>

<p>Consider the task of designing a system to perform arithmetic with
rational numbers. We could imagine an operation <code>add-rat</code> that takes
two rational numbers and produces their sum. In terms of simple data,
a rational number can be thought of as two integers: a numerator and a
denominator. Thus, we could design a program in which each rational
number would be represented by two integers (a numerator and a
denominator) and where <code>add-rat</code> would be implemented by two functions
(one producing the numerator of the sum and one producing the
denominator). But this would be awkward, because we would then need to
explicitly keep track of which numerators corresponded to which
denominators. In a system intended to perform many operations on many
rational numbers, such bookkeeping details would clutter the programs
substantially, to say nothing of what they would do to our minds. It
would be much better if we could “glue together” a numerator and
denominator to form a pair, a <em>compound data object</em>, that our
programs could manipulate in a way that would be consistent with
regarding a rational number as a single conceptual unit.</p>

<p>The use of compound data also enables us to increase the modularity of
our programs. If we can manipulate rational numbers directly as
objects in their own right, then we can separate the part of our
program that deals with rational numbers per se from the details of
how rational numbers may be represented as pairs of integers. The
general technique of isolating the parts of a program that deal with
how data objects are represented from the parts of a program that deal
with how data objects are used is a powerful design methodology called
<em>data abstraction</em>. We will see how data abstraction makes programs
much easier to design, maintain, and modify.</p>

<p>The use of compound data leads to a real increase in the expressive
power of our programming language. Consider the idea of forming a
“linear combination” $ax + by$. We might like to write a function that
would accept $a$, $b$, $x$, and $y$ as arguments and return the value of
$ax +by$.  This presents no difficulty if the arguments are to be
numbers, because we can readily define the function</p>

<pre><code class="clojure">(defn linear-combination [a b x y]
  (+ (* a x) (* b y)))
</code></pre>

<p>But suppose we are not concerned only with numbers. Suppose we would
like to express, in procedural terms, the idea that one can form
linear combinations whenever addition and multiplication are defined -
for rational numbers, complex numbers, polynomials, or whatever. We
could express this as a function of the form</p>

<pre><code class="clojure">(defn linear-combination [a b x y]
  (add (mul a x) (mul b y)))
</code></pre>

<p>where <code>add</code> and <code>mul</code> are not the primitive functions <code>+</code> and <code>*</code> but
rather more complex things that will perform the appropriate
operations for whatever kinds of data we pass in as the arguments <code>a</code>
, <code>b</code> ,<code>x</code> , and <code>y</code> . The key point is that the only thing
<code>linear-combination</code> should need to know about <code>a</code> , <code>b</code>, <code>x</code> , and
<code>y</code> is that the functions <code>add</code> and <code>mul</code> will perform the appropriate
manipulations. From the perspective of the function
<code>linear-combination</code> , it is irrelevant what <code>a</code> , <code>b</code> , <code>x</code> , and <code>y</code>
are and even more irrelevant how they might happen to be represented
in terms of more primitive data. This same example shows why it is
important that our programming language provide the ability to
manipulate compound objects directly: Without this, there is no way
for a function such as <code>linear-combination</code> to pass its arguments
along to <code>add</code> and <code>mul</code> without having to know their detailed
structure.</p>

<p>We begin this chapter by implementing the rational-number arithmetic
system mentioned above, using the same primitives as scheme - <code>cons</code>,
<code>car</code> and <code>cdr</code>, but then leave them in favour of using Clojure&#39;s
datatypes.</p>

<p>As with user-defined functions, the main issue to be addressed is that
of abstraction as a technique for coping with complexity, and we will
see how data abstraction enables us to erect suitable <em>abstraction
barriers</em> between different parts of a program.</p>

<p>We will see that the key to forming compound data is that a
programming language should provide some kind of “glue” so that data
objects can be combined to form more complex data objects. There are
many possible kinds of glue. Indeed, we will discover how to form
compound data using no special “data” operations at all, only
functions.  This will further blur the distinction between “function”
and “data,”. We will also explore some conventional techniques for
representing trees. One key idea in dealing with compound data is the
notion of <em>closure</em> —that the glue we use for combining data objects
should allow us to combine not only primitive data objects, but
compound data objects as well. Another key idea is that compound data
objects can serve as <em>conventional interfaces</em> for combining program
modules in mix-and-match ways. We illustrate some of these ideas by
presenting a simple graphics language that exploits closure.</p>

<p>We will then augment the representational power of our language by
introducing <em>symbolic expressions</em>, data whose elementary parts can be
arbitrary symbols rather than only numbers. We explore various
alternatives for representing sets of objects. We will find that, just
as a given numerical function can be computed by many different
computational processes, there are many ways in which a given data
structure can be represented in terms of simpler objects, and the
choice of representation can have significant impact on the time and
space requirements of processes that manipulate the data. We will
investigate these ideas in the context of the representation of sets
and the encoding of information.</p>

<p>Next we will take up the problem of working with data that may be
represented differently by different parts of a program. This leads to
the need to implement <em>generic operations</em>, which must handle many
different types of data. Maintaining modularity in the presence of
generic operations requires more powerful abstraction barriers than
can be erected with simple data abstraction alone. In particular, we
introduce data directed programming as a technique that allows
individual data representations to be designed in isolation and then
combined <em>additively</em> (i.e., without modification).</p>

<p>TODO: Edit last few sentences</p>

</div>
<script src='https://cdn.polyfill.io/v1/polyfill.min.js'></script>
<script src="/sicpdistilled/javascripts/all-0c20c227.js"></script>
<link href='http://app.klipse.tech/css/codemirror.css' rel='stylesheet' type='text/css'>
<script>
  window.klipse_settings = {
    selector: 'code.clojure'
  };
</script>
<script src='http://app.klipse.tech/dev/js/klipse_plugin.js'></script>
</body>
