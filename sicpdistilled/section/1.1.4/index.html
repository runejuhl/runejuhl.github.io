<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8'>
<meta content='IE=edge,chrome=1' http-equiv='X-UA-Compatible'>
<meta content='width=device-width; initial-scale=1' name='viewport'>
<title>SICP Distilled</title>
<link href='http://fonts.googleapis.com/css?family=Droid+Serif' rel='stylesheet' type='text/css'>
<link href="/sicpdistilled/stylesheets/all-e81cfb05.css" rel="stylesheet" />
<script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
<script type='text/x-mathjax-config'>
MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>
</head>
</html>
<body>
<div class='menu--mobile js-mobile-nav' data-target='menu'>Menu</div>
<div class='menu'>
<a href='/'>
<img alt='SICP Distilled' class='logo' src='/sicpdistilled/images/sicp2-07ad7dbe.jpg'>
</a>
<h1 class='menu__title done'>
<a href='/'>
SICP Distilled
</a>
</h1>
<ul class='menu__list'>
<li class='done'>
<a href='/sicpdistilled/section/licence'>
<img alt='CC by-sa' src='https://i.creativecommons.org/l/by-sa/4.0/88x31.png' style='border-width:0'>
Licence
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/donate'>
<img alt='MSF ' src='/sicpdistilled/images/msf-b09b7038.jpg' style='border-width:0' width='88px'>
Donate
</a>
</li>
</ul>
<h2>Ch1 - Building Abstractions With Functions</h2>
<ul class='menu__list'>
<li class='done'>
<a href='/sicpdistilled/section/1-distilled'>
Chapter 1 Distilled
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1-intro'>
Introduction
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1'>
1.1 - The Elements Of Programming
</a>
</li>
<ul class='menu__list_2'>
<li class='done'>
<a href='/sicpdistilled/section/1.1.1'>
Expressions
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.2'>
Naming and the Environment
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.3'>
Evaluating Combinations
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.4'>
Defining New Functions
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.5'>
The Substitution Model
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1-exercises'>
Exercises
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.6a'>
Predicates
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.6b'>
Conditional Expressions
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.7'>
Example: Newtonâ€™s Method
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.8'>
Functions as Black-Box Abstractions
</a>
</li>
</ul>
<li class='done'>
<a href='/sicpdistilled/section/1.2'>
1.2 - Procedures and the Processes They Generate
</a>
</li>
<ul class='menu__list_2'>
<li class='done'>
<a href='/sicpdistilled/section/1.2.1'>
Linear Recursion and Iteration
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.2.2'>
Tree Recursion
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.2.3'>
Orders of Growth
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.2.4'>
Exponentiation
</a>
</li>
<il class='done'>
<a href='/sicpdistilled/section/1.2.5'>
Greatest Common Divisors
</a>
</il>
<li class='done'>
<a href='/sicpdistilled/section/1.2.6'>
Example: Testing For Primality
</a>
</li>
</ul>
<li class='done'>
<a href='/sicpdistilled/section/1.3-higher-order'>
1.3 Higher Order Functions
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/project-blackjack'>
Project - Blackjack
</a>
</li>
</ul>
<h2>Ch2 - Building Abstractions With Data</h2>
<ul class='menu__list'>
<li class='done'>
<a href='/sicpdistilled/section/2-distilled'>
Chapter 2 Distilled
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/2-intro'>
Introduction
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/2-data-abstraction'>
Data Abstraction
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/2-nothing'>
Everything From Nothing
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/2-abstractions'>
Abstractions In Clojure
</a>
</li>
<li>
<a href='/sicpdistilled/section/2-data-structures'>
Clojure's Data Structures
</a>
</li>
<li>
<a href='/sicpdistilled/section/2-data-abstraction-clj'>
Data Abstraction, Revisited
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/2-escher'>
Escher
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/project-escher'>
Project - Escher
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/2-symbolic'>
Symbolic Data
</a>
</li>
<li>
<a href='/sicpdistilled/section/2-sets'>
Representing Sets
</a>
</li>
<li>
<a href='/sicpdistilled/section/2-escher'>
Huffman Encoding Trees
</a>
</li>
<li>
<a href='/sicpdistilled/section/2-zippers'>
Zippers
</a>
</li>
</ul>
<h2>Ch3 - Modularity, Objects, and State</h2>
<h2>Ch4 - Metalinguistic Abstraction</h2>
<ul class='menu__list'>
<li class='done'>
<a href='/sicpdistilled/section/4.1'>
4.1 - The Metacircular Evaluator
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/halting'>
The Halting Problem
</a>
</li>
<li>
<a href='/sicpdistilled/section/y'>
The Y Combinator
</a>
</li>
<li>
<a href='/sicpdistilled/section/4.2'>
4.2 - Lazy Evaluation
</a>
</li>
<li>
<a href='/sicpdistilled/section/4.3'>
4.3 - Nondeterministic Computing
</a>
</li>
<li>
<a href='/sicpdistilled/section/4.4'>
4.4 - Logic Programming
</a>
</li>
</ul>
</div>
<div class='container menu--push'>
<h1>Defining New Functions</h1>

<p>So far we have:</p>

<h2>Primitives</h2>

<ul>
<li>Data (numbers, strings, keywords, chars)</li>
<li>Functions (arithmetic)</li>
</ul>

<p>We can:</p>

<h3>Combine operations by nesting.</h3>

<pre><code class="clojure">(+ (* 3 5)
   (- (/ 4 3) (* 2 9)))
</code></pre>

<h3>Associate names with values.</h3>

<pre><code class="clojure">(def a 3)
(+ a 2)
</code></pre>

<p>Now we will learn how to make our own functions, and learn our first model of how to evaluate them.</p>

<p>We can make a function that squares a number:</p>

<pre><code class="clojure">(defn square [x]
  (* x x))
</code></pre>

<p>In general we create functions as follows:</p>

<pre><code>(defn &lt;name&gt; [&lt;formal parameters&gt;]
  &lt;body&gt;)
</code></pre>

<p>The <code>&lt;name&gt;</code> is a symbol to be associated with the function defined, in the global environment.</p>

<p>The <code>&lt;formal parameters&gt;</code> are the names used within the body of the function to refer to the corresponding arguments of the function.</p>

<p>The <code>[ ]</code> is actually a Clojure <em>vector</em>, we look at data structures in Ch2.</p>

<p>The <code>&lt;body&gt;</code> is an expression that will yield the value of the function application when the formal parameters are replaced by the actual arguments to which the function is applied.</p>

<p>Once we name it, we can of course use it in expressions</p>

<pre><code class="clojure">&gt; (square 21)
441
</code></pre>

<pre><code class="clojure">&gt; (square (+ 2 5))
49
</code></pre>

<pre><code class="clojure">&gt; (square (square 3))
81
</code></pre>

<p>We can have multiple arguments to our functions:</p>

<pre><code class="clojure">(defn spread [x y z]
  (- (max x y z) (min x y z)))
</code></pre>

<p>This function computes the range of 3 numbers, I called this <code>spread</code> rather
than <code>range</code> as <code>range</code> is a builtin function in Clojure.</p>

<p>If we call a function with the wrong number of arguments, we get an error</p>

<pre><code class="clojure">&gt; (spread 10)
clojure.lang.ArityException:
  Wrong number of args (1) passed to:
                  sandbox24425$spread
</code></pre>

<p>The technical word for number of arguments is <em><a href="https://en.wikipedia.org/wiki/Arity">arity</a></em> (that&#39;s why we get an <code>Arityexception</code> here)</p>

<p>We can specify different arities for the same function</p>

<pre><code class="clojure">(defn spread
  ([x] x)
  ([x y] (- (max x y) (min x y)))
  ([x y z] (- (max x y z) (min x y z))))
</code></pre>

<p>Or we can do <em>variadic</em> (ie a variable number of arguments)</p>

<pre><code class="clojure">(defn spread [&amp; nums]
  (- (apply max nums) (apply min nums)))
</code></pre>

<p>Here the arguments are collected as a sequence called <code>nums</code>.</p>

<p><code>apply</code> takes a function and a sequence and calls the function with the elements
of the sequence as args, so</p>

<pre><code class="clojure">(apply max [5 1 7 4])
</code></pre>

<p>is the same as</p>

<pre><code class="clojure">(max 5 1 7 4)
</code></pre>

</div>
<script src='https://cdn.polyfill.io/v1/polyfill.min.js'></script>
<script src="/sicpdistilled/javascripts/all-0c20c227.js"></script>
</body>
