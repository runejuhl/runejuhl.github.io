<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8'>
<meta content='IE=edge,chrome=1' http-equiv='X-UA-Compatible'>
<meta content='width=device-width; initial-scale=1' name='viewport'>
<title>SICP Distilled</title>
<link href='http://fonts.googleapis.com/css?family=Droid+Serif' rel='stylesheet' type='text/css'>
<link href="/sicpdistilled/stylesheets/all-e81cfb05.css" rel="stylesheet" />
<script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
<script type='text/x-mathjax-config'>
MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>
</head>
</html>
<body>
<div class='menu--mobile js-mobile-nav' data-target='menu'>Menu</div>
<div class='menu'>
<a href='/'>
<img alt='SICP Distilled' class='logo' src='/sicpdistilled/images/sicp2-07ad7dbe.jpg'>
</a>
<h1 class='menu__title done'>
<a href='/'>
SICP Distilled
</a>
</h1>
<ul class='menu__list'>
<li class='done'>
<a href='/sicpdistilled/section/licence'>
<img alt='CC by-sa' src='https://i.creativecommons.org/l/by-sa/4.0/88x31.png' style='border-width:0'>
Licence
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/donate'>
<img alt='MSF ' src='/sicpdistilled/images/msf-b09b7038.jpg' style='border-width:0' width='88px'>
Donate
</a>
</li>
</ul>
<h2>Ch1 - Building Abstractions With Functions</h2>
<ul class='menu__list'>
<li class='done'>
<a href='/sicpdistilled/section/1-distilled'>
Chapter 1 Distilled
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1-intro'>
Introduction
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1'>
1.1 - The Elements Of Programming
</a>
</li>
<ul class='menu__list_2'>
<li class='done'>
<a href='/sicpdistilled/section/1.1.1'>
Expressions
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.2'>
Naming and the Environment
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.3'>
Evaluating Combinations
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.4'>
Defining New Functions
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.5'>
The Substitution Model
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1-exercises'>
Exercises
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.6a'>
Predicates
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.6b'>
Conditional Expressions
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.7'>
Example: Newton’s Method
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.8'>
Functions as Black-Box Abstractions
</a>
</li>
</ul>
<li class='done'>
<a href='/sicpdistilled/section/1.2'>
1.2 - Procedures and the Processes They Generate
</a>
</li>
<ul class='menu__list_2'>
<li class='done'>
<a href='/sicpdistilled/section/1.2.1'>
Linear Recursion and Iteration
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.2.2'>
Tree Recursion
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.2.3'>
Orders of Growth
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.2.4'>
Exponentiation
</a>
</li>
<il class='done'>
<a href='/sicpdistilled/section/1.2.5'>
Greatest Common Divisors
</a>
</il>
<li class='done'>
<a href='/sicpdistilled/section/1.2.6'>
Example: Testing For Primality
</a>
</li>
</ul>
<li class='done'>
<a href='/sicpdistilled/section/1.3-higher-order'>
1.3 Higher Order Functions
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/project-blackjack'>
Project - Blackjack
</a>
</li>
</ul>
<h2>Ch2 - Building Abstractions With Data</h2>
<ul class='menu__list'>
<li class='done'>
<a href='/sicpdistilled/section/2-distilled'>
Chapter 2 Distilled
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/2-intro'>
Introduction
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/2-data-abstraction'>
Data Abstraction
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/2-nothing'>
Everything From Nothing
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/2-abstractions'>
Abstractions In Clojure
</a>
</li>
<li>
<a href='/sicpdistilled/section/2-data-structures'>
Clojure's Data Structures
</a>
</li>
<li>
<a href='/sicpdistilled/section/2-data-abstraction-clj'>
Data Abstraction, Revisited
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/2-escher'>
Escher
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/project-escher'>
Project - Escher
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/2-symbolic'>
Symbolic Data
</a>
</li>
<li>
<a href='/sicpdistilled/section/2-sets'>
Representing Sets
</a>
</li>
<li>
<a href='/sicpdistilled/section/2-escher'>
Huffman Encoding Trees
</a>
</li>
<li>
<a href='/sicpdistilled/section/2-zippers'>
Zippers
</a>
</li>
</ul>
<h2>Ch3 - Modularity, Objects, and State</h2>
<h2>Ch4 - Metalinguistic Abstraction</h2>
<ul class='menu__list'>
<li class='done'>
<a href='/sicpdistilled/section/4.1'>
4.1 - The Metacircular Evaluator
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/halting'>
The Halting Problem
</a>
</li>
<li>
<a href='/sicpdistilled/section/y'>
The Y Combinator
</a>
</li>
<li>
<a href='/sicpdistilled/section/4.2'>
4.2 - Lazy Evaluation
</a>
</li>
<li>
<a href='/sicpdistilled/section/4.3'>
4.3 - Nondeterministic Computing
</a>
</li>
<li>
<a href='/sicpdistilled/section/4.4'>
4.4 - Logic Programming
</a>
</li>
</ul>
</div>
<div class='container menu--push'>
<h1>Greatest Common Divisors</h1>

<p>The greatest common divisor (GCD) of two integers a and b is defined to
be the largest integer that divides both a and b with no remainder. For
example, the GCD of 16 and 28 is 4. In Chapter 2, when we investigate
how to implement rational-number arithmetic, we will need to be able
to compute GCDs in order to reduce rational numbers to lowest terms.
(To reduce a rational number to lowest terms, we must divide both the
numerator and the denominator by their GCD. For example, 16/28 reduces to 4/7.) One way to find the GCD of two integers is to factor them
and search for common factors, but there is a famous algorithm that is
much more efficient.</p>

<p>The idea of the algorithm is based on the observation that, if r is the
remainder when a is divided by b, then the common divisors of a and b
are precisely the same as the common divisors of b and r . Thus, we can</p>

<p>use the equation</p>

<pre><code>GCD(a,b) = GCD(b,r)
</code></pre>

<p>to successively reduce the problem of computing a GCD to the problem
of computing the GCD of smaller and smaller pairs of integers. For example,</p>

<pre><code>GCD(206,40) = GCD(40,6)
            = GCD(6,4)
            = GCD(4,2)
            = GCD(2,0)
            = 2
</code></pre>

<p>It is possible to show that starting with any two positive integers
and performing repeated reductions will always eventually produce a
pair where the second number is <code>0</code>. Then the GCD is the other number
in the pair.</p>

<p>This method for computing the GCD is known as <em>Euclid’s Algorithm</em>, it
is easy to express it as a procedure:</p>

<pre><code class="clojure">(defn gcd [a b]
  (if (= b 0)
      a
      (recur b (rem a b))))
</code></pre>

<p>This generates an iterative process, whose number of steps grows as the
logarithm of the numbers involved.</p>

<h1>Exercise 1.20:</h1>

<p>The process that a procedure generates is
of course dependent on the rules used by the interpreter.
As an example, consider the iterative gcd procedure given
above. Suppose we were to interpret this procedure using
normal-order evaluation, as discussed in Section 1.1.5. (The
normal-order-evaluation rule for if is described in Exercise
1.5.)</p>

<p>Using the substitution method (for normal order), illustrate the process generated in evaluating (gcd 206 40) and
indicate the remainder operations that are actually performed.</p>

<p>How many remainder operations are actually performed in:</p>

<ul>
<li>the normal-order evaluation of (gcd 206 40) ?</li>
<li>the applicative-order evaluation?</li>
</ul>

</div>
<script src='https://cdn.polyfill.io/v1/polyfill.min.js'></script>
<script src="/sicpdistilled/javascripts/all-0c20c227.js"></script>
</body>
