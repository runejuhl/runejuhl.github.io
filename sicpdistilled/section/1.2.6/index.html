<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8'>
<meta content='IE=edge,chrome=1' http-equiv='X-UA-Compatible'>
<meta content='width=device-width; initial-scale=1' name='viewport'>
<title>SICP Distilled</title>
<link href='http://fonts.googleapis.com/css?family=Droid+Serif' rel='stylesheet' type='text/css'>
<link href="/sicpdistilled/stylesheets/all-e81cfb05.css" rel="stylesheet" />
<script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
<script type='text/x-mathjax-config'>
MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>
</head>
</html>
<body>
<div class='menu--mobile js-mobile-nav' data-target='menu'>Menu</div>
<div class='menu'>
<a href='/'>
<img alt='SICP Distilled' class='logo' src='/sicpdistilled/images/sicp2-07ad7dbe.jpg'>
</a>
<h1 class='menu__title done'>
<a href='/'>
SICP Distilled
</a>
</h1>
<ul class='menu__list'>
<li class='done'>
<a href='/sicpdistilled/section/licence'>
<img alt='CC by-sa' src='https://i.creativecommons.org/l/by-sa/4.0/88x31.png' style='border-width:0'>
Licence
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/donate'>
<img alt='MSF ' src='/sicpdistilled/images/msf-b09b7038.jpg' style='border-width:0' width='88px'>
Donate
</a>
</li>
</ul>
<h2>Ch1 - Building Abstractions With Functions</h2>
<ul class='menu__list'>
<li class='done'>
<a href='/sicpdistilled/section/1-distilled'>
Chapter 1 Distilled
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1-intro'>
Introduction
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1'>
1.1 - The Elements Of Programming
</a>
</li>
<ul class='menu__list_2'>
<li class='done'>
<a href='/sicpdistilled/section/1.1.1'>
Expressions
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.2'>
Naming and the Environment
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.3'>
Evaluating Combinations
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.4'>
Defining New Functions
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.5'>
The Substitution Model
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1-exercises'>
Exercises
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.6a'>
Predicates
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.6b'>
Conditional Expressions
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.7'>
Example: Newton’s Method
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.8'>
Functions as Black-Box Abstractions
</a>
</li>
</ul>
<li class='done'>
<a href='/sicpdistilled/section/1.2'>
1.2 - Procedures and the Processes They Generate
</a>
</li>
<ul class='menu__list_2'>
<li class='done'>
<a href='/sicpdistilled/section/1.2.1'>
Linear Recursion and Iteration
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.2.2'>
Tree Recursion
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.2.3'>
Orders of Growth
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.2.4'>
Exponentiation
</a>
</li>
<il class='done'>
<a href='/sicpdistilled/section/1.2.5'>
Greatest Common Divisors
</a>
</il>
<li class='done'>
<a href='/sicpdistilled/section/1.2.6'>
Example: Testing For Primality
</a>
</li>
</ul>
<li class='done'>
<a href='/sicpdistilled/section/1.3-higher-order'>
1.3 Higher Order Functions
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/project-blackjack'>
Project - Blackjack
</a>
</li>
</ul>
<h2>Ch2 - Building Abstractions With Data</h2>
<ul class='menu__list'>
<li class='done'>
<a href='/sicpdistilled/section/2-distilled'>
Chapter 2 Distilled
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/2-intro'>
Introduction
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/2-data-abstraction'>
Data Abstraction
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/2-nothing'>
Everything From Nothing
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/2-abstractions'>
Abstractions In Clojure
</a>
</li>
<li>
<a href='/sicpdistilled/section/2-data-structures'>
Clojure's Data Structures
</a>
</li>
<li>
<a href='/sicpdistilled/section/2-data-abstraction-clj'>
Data Abstraction, Revisited
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/2-escher'>
Escher
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/project-escher'>
Project - Escher
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/2-symbolic'>
Symbolic Data
</a>
</li>
<li>
<a href='/sicpdistilled/section/2-sets'>
Representing Sets
</a>
</li>
<li>
<a href='/sicpdistilled/section/2-escher'>
Huffman Encoding Trees
</a>
</li>
<li>
<a href='/sicpdistilled/section/2-zippers'>
Zippers
</a>
</li>
</ul>
<h2>Ch3 - Modularity, Objects, and State</h2>
<h2>Ch4 - Metalinguistic Abstraction</h2>
<ul class='menu__list'>
<li class='done'>
<a href='/sicpdistilled/section/4.1'>
4.1 - The Metacircular Evaluator
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/halting'>
The Halting Problem
</a>
</li>
<li>
<a href='/sicpdistilled/section/y'>
The Y Combinator
</a>
</li>
<li>
<a href='/sicpdistilled/section/4.2'>
4.2 - Lazy Evaluation
</a>
</li>
<li>
<a href='/sicpdistilled/section/4.3'>
4.3 - Nondeterministic Computing
</a>
</li>
<li>
<a href='/sicpdistilled/section/4.4'>
4.4 - Logic Programming
</a>
</li>
</ul>
</div>
<div class='container menu--push'>
<h1>Example: Testing for Primality</h1>

<p>This section describes two methods for checking the primality of an
integer <code>n</code>, one with order of growth $ \Theta(n) $, and a
“probabilistic” algorithm with order of growth $ \Theta(\log n) $.</p>

<h2>Searching for divisors</h2>

<p>Since ancient times, mathematicians have been fascinated by problems
concerning prime numbers, and many people have worked on the problem
of determining ways to test if numbers are prime. One way to test if a
number is prime is to find the number’s divisors. The following
program finds the smallest integral divisor (greater than 1) of a
given number n. It does this in a straightforward way, by testing n
for divisibility by successive integers starting with 2.</p>

<pre><code class="clojure">(defn smallest-divisor [n]
  (find-divisor n 2))

(defn find-divisor [n test-divisor]
  (cond (&gt; (square test-divisor) n) n
        (divides? test-divisor n) test-divisor
        :else (find-divisor n (+ test-divisor 1))))

(defn divides? [a b]
  (= (remainder b a) 0))
</code></pre>

<p>We can test whether a number is prime as follows: n is prime if and only
if n is its own smallest divisor.</p>

<pre><code class="clojure">(defn prime? [n]
  (= n (smallest-divisor n)))
</code></pre>

<p>The end test for find-divisor is based on the fact that if n is not
prime it must have a divisor less than or equal to $\sqrt n $. This
means that the algorithm need only test divisors between $1$ and
$\sqrt n $. Consequently, the number of steps required to identify $n$
as prime will have order of growth $ \Theta(\sqrt n) $</p>

<h2>The Fermat Test</h2>

<p>The $ \Theta(\log n) $ primality test is based on a result from
number theory</p>

<blockquote> If n is a prime number and a is any positive integer less
than n, then a raised to the n<sup>th</sup> power is congruent to a
modulo n.  <cite>Fermat’s Little Theorem</cite></blockquote>

<p>(Two numbers are said to be congruent modulo n if they both have the
same remainder when divided by n. The remainder of a number a when
divided by n is also referred to as the remainder of a modulo n, or
simply as a modulo n.)</p>

<p>If n is not prime, then, in general, most of the numbers $a \lt n$ will
not satisfy the above relation. This leads to the following algorithm
for testing primality:</p>

<ul>
<li><p>Given a number n, pick a random number $a \lt n$ and compute the
remainder of $ a^n $ modulo n.</p>

<ul>
<li>If the result is not equal to a, then n is certainly not prime.</li>
<li>If it is a, then chances are good that n is prime.</li>
</ul></li>
<li><p>Now pick another random number a and test it with the
same method.</p>

<ul>
<li>If it also satisfies the equation, then we can be even
more confident that n is prime.</li>
</ul></li>
</ul>

<p>By trying more and more values of a, we can increase our confidence in
the result.  This algorithm is known as the <em>Fermat test</em>.</p>

<p>To implement it, we need a procedure that computes the of
exponential a number modulo another number:</p>

<pre><code class="clojure">(defn expmod [base exp m]
  (cond (= exp 0)
        1
        (even? exp)
        (rem (square (expmod base (/ exp 2) m))
             m)
        :else
        (rem (* base (expmod base (dec exp) m))
             m)))
</code></pre>

<p>This is very similar to the <code>fast-expt</code> function earlier. It uses
successive squaring, so that the number of steps grows logarithmically
with the exponent. The Fermat test is performed by choosing at random
a number a between $1$ and $n−1$ inclusive and checking whether the
remainder modulo $n$ of the $n^\text{th}$ power of $a$ is equal to
$a$. The random number a is chosen using the procedure <code>rand-int</code>, a
Clojure built-in.</p>

<p><code>rand-int</code> returns a nonnegative integer less than its integer
input. Hence, to obtain a random number between <code>1</code> and <code>n − 1</code>, we call
random with an input of <code>n − 1</code> and add <code>1</code> to the result:</p>

<pre><code class="clojure">(defn fermat-test [n]
  (let [a (inc (rand-int (dec n)))]
    (= (expmod a n n) a)))
</code></pre>

<p>The following procedure runs the test on <code>n</code>, repeating <code>num-tests</code>
times.  Its value is true if the test succeeds every time, and false
otherwise.</p>

<pre><code class="clojure">(defn fast-prime?
  ([n] (fast-prime? n 50))
  ([n num-tests]
     (every? true? (take num-tests (repeatedly #(fermat-test n))))))
</code></pre>

<p>We have used some of Clojure&#39;s sequence functions here, reading from
right to left:</p>

<p><code>fast-prime?</code> <code>repeatedly</code> runs <code>#(fermat-test n)</code>, takes <code>num-tests</code>
of them, sees if <code>every?</code> one of them is <code>true?</code></p>

<p>(<code>every?</code> short-circuits, if any of them are false it has failed the
test and will be reported as non-prime)</p>

<h1>Probabilistic Methods</h1>

<p>The Fermat test differs in character from most familiar algorithms, in
which one computes an answer that is guaranteed to be correct. Here,
the answer obtained is only probably correct. More precisely, if n
ever fails the Fermat test, we can be certain that $n$ is not
prime. But the fact that $n$ passes the test, while an extremely
strong indication, is still not a guarantee that $n$ is prime. What we
would like to say is that for any number n, if we perform the test
enough times and find that $n$ always passes the test, then the
probability of error in our primality test can be made as small as we
like.</p>

<p>Unfortunately, this assertion is not quite correct. There do exist
numbers that fool the Fermat test: numbers $n$ that are not prime and
yet have the property that a $n$ is congruent to a modulo $n$ for all
integers $a \lt n$.  Such numbers are extremely rare, so the Fermat
test is quite reliable in practice.</p>

<p>There are variations of the Fermat test that cannot be fooled. In
these tests, as with the Fermat method, one tests the primality of an
integer $n$ by choosing a random integer $a \lt n$ and checking some
condition that depends upon $n$ and a. (See Exercise 1.28 for an
example of such a test.)  On the other hand, in contrast to the Fermat
test, one can prove that, for any n, the condition does not hold for
most of the integers $a \lt n$ unless $n$ is prime. Thus, if $n$
passes the test for some random choice of a, the chances are better
than even that $n$ is prime. If $n$ passes the test for two random
choices of a, the chances are better than 3 out of 4 that $n$ is
prime. By running the test with more and more randomly chosen values
of a we can make the probability of error as small as we like.</p>

<p>The existence of tests for which one can prove that the chance of
error becomes arbitrarily small has sparked interest in algorithms of
this type, which have come to be known as probabilistic
algorithms. There is a great deal of research activity in this area,
and probabilistic algorithms have been fruitfully applied to many
fields.</p>

</div>
<script src='https://cdn.polyfill.io/v1/polyfill.min.js'></script>
<script src="/sicpdistilled/javascripts/all-0c20c227.js"></script>
</body>
