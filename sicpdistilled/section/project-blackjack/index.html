<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8'>
<meta content='IE=edge,chrome=1' http-equiv='X-UA-Compatible'>
<meta content='width=device-width; initial-scale=1' name='viewport'>
<title>SICP Distilled</title>
<link href='http://fonts.googleapis.com/css?family=Droid+Serif' rel='stylesheet' type='text/css'>
<link href="/sicpdistilled/stylesheets/all-e81cfb05.css" rel="stylesheet" />
<script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
<script type='text/x-mathjax-config'>
MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>
</head>
</html>
<body>
<div class='menu--mobile js-mobile-nav' data-target='menu'>Menu</div>
<div class='menu'>
<a href='/'>
<img alt='SICP Distilled' class='logo' src='/sicpdistilled/images/sicp2-07ad7dbe.jpg'>
</a>
<h1 class='menu__title done'>
<a href='/'>
SICP Distilled
</a>
</h1>
<ul class='menu__list'>
<li class='done'>
<a href='/sicpdistilled/section/licence'>
<img alt='CC by-sa' src='https://i.creativecommons.org/l/by-sa/4.0/88x31.png' style='border-width:0'>
Licence
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/donate'>
<img alt='MSF ' src='/sicpdistilled/images/msf-b09b7038.jpg' style='border-width:0' width='88px'>
Donate
</a>
</li>
</ul>
<h2>Ch1 - Building Abstractions With Functions</h2>
<ul class='menu__list'>
<li class='done'>
<a href='/sicpdistilled/section/1-distilled'>
Chapter 1 Distilled
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1-intro'>
Introduction
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1'>
1.1 - The Elements Of Programming
</a>
</li>
<ul class='menu__list_2'>
<li class='done'>
<a href='/sicpdistilled/section/1.1.1'>
Expressions
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.2'>
Naming and the Environment
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.3'>
Evaluating Combinations
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.4'>
Defining New Functions
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.5'>
The Substitution Model
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1-exercises'>
Exercises
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.6a'>
Predicates
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.6b'>
Conditional Expressions
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.7'>
Example: Newtonâ€™s Method
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.8'>
Functions as Black-Box Abstractions
</a>
</li>
</ul>
<li class='done'>
<a href='/sicpdistilled/section/1.2'>
1.2 - Procedures and the Processes They Generate
</a>
</li>
<ul class='menu__list_2'>
<li class='done'>
<a href='/sicpdistilled/section/1.2.1'>
Linear Recursion and Iteration
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.2.2'>
Tree Recursion
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.2.3'>
Orders of Growth
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.2.4'>
Exponentiation
</a>
</li>
<il class='done'>
<a href='/sicpdistilled/section/1.2.5'>
Greatest Common Divisors
</a>
</il>
<li class='done'>
<a href='/sicpdistilled/section/1.2.6'>
Example: Testing For Primality
</a>
</li>
</ul>
<li class='done'>
<a href='/sicpdistilled/section/1.3-higher-order'>
1.3 Higher Order Functions
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/project-blackjack'>
Project - Blackjack
</a>
</li>
</ul>
<h2>Ch2 - Building Abstractions With Data</h2>
<ul class='menu__list'>
<li class='done'>
<a href='/sicpdistilled/section/2-distilled'>
Chapter 2 Distilled
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/2-intro'>
Introduction
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/2-data-abstraction'>
Data Abstraction
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/2-nothing'>
Everything From Nothing
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/2-abstractions'>
Abstractions In Clojure
</a>
</li>
<li>
<a href='/sicpdistilled/section/2-data-structures'>
Clojure's Data Structures
</a>
</li>
<li>
<a href='/sicpdistilled/section/2-data-abstraction-clj'>
Data Abstraction, Revisited
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/2-escher'>
Escher
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/project-escher'>
Project - Escher
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/2-symbolic'>
Symbolic Data
</a>
</li>
<li>
<a href='/sicpdistilled/section/2-sets'>
Representing Sets
</a>
</li>
<li>
<a href='/sicpdistilled/section/2-escher'>
Huffman Encoding Trees
</a>
</li>
<li>
<a href='/sicpdistilled/section/2-zippers'>
Zippers
</a>
</li>
</ul>
<h2>Ch3 - Modularity, Objects, and State</h2>
<h2>Ch4 - Metalinguistic Abstraction</h2>
<ul class='menu__list'>
<li class='done'>
<a href='/sicpdistilled/section/4.1'>
4.1 - The Metacircular Evaluator
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/halting'>
The Halting Problem
</a>
</li>
<li>
<a href='/sicpdistilled/section/y'>
The Y Combinator
</a>
</li>
<li>
<a href='/sicpdistilled/section/4.2'>
4.2 - Lazy Evaluation
</a>
</li>
<li>
<a href='/sicpdistilled/section/4.3'>
4.3 - Nondeterministic Computing
</a>
</li>
<li>
<a href='/sicpdistilled/section/4.4'>
4.4 - Logic Programming
</a>
</li>
</ul>
</div>
<div class='container menu--push'>
<h1>Blackjack</h1>

<p>Testing your understanding of higher order functions by creating strategys for <a href="https://en.wikipedia.org/wiki/Blackjack">Blackjack</a> (also called Pontoon or 21)</p>

<p>Checkout the project from <a href="https://github.com/SICPDistilled/blackjack">Github</a></p>

<p>Join the chat at <a href="https://gitter.im/SICPDistilled/blackjack?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge"><img alt="Gitter" src="https://badges.gitter.im/Join%20Chat.svg" /></a></p>

<p>We are going to build an increasingly complex model of playing Blackjack alongside strategys to play the game</p>

<h2>Starting out</h2>

<h3>A simple model for the deck</h3>

<p>We begin with a very simple model of both cards and the deck, we assume that they take a value from 1-10 and anything is equally likely, we can get a new card by calling <code>deal</code></p>

<pre><code class="clojure">(defn deal []
  (inc (rand-int 10)))
</code></pre>

<h3>Modelling hands</h3>

<p>See the simple-hand namespace:
If a hand is a vector of numbers, we can make a new hand by defining</p>

<pre><code class="clojure">(defn new-hand [] [(deal)])
</code></pre>

<p>and have the following helper functions to deal with them</p>

<pre><code class="clojure">(defn up-card [hand]
  (first hand))

(defn add-card [hand card]
  (conj hand card))

(defn total [hand]
  (reduce + hand))
</code></pre>

<h3>Strategies</h3>

<p>We will model a strategy as a procedure of the current hand and the dealers &#39;up card&#39; (which a decent strategy will take into account) that returns true or false if it decides to &#39;hit&#39;.</p>

<p>Take a look at the <code>play-game</code> procedure: it takes 2 strategies, for the player and dealer then uses <code>play-hand</code> to play the players hand and then (if the player didnt bust), plays the dealers hand. It returns 1 if the player wins and 0 if she loses.</p>

<p>The <code>play-hand</code> procedure takes a strategy, a hand (list of cards) and the visible card of the opponent, it always returns a hand and will stop if either</p>

<ul>
<li>the strategy decides to stop</li>
</ul>

<p>or</p>

<ul>
<li>the player goes bust</li>
</ul>

<p>otherwise it takes a card and recurs</p>

<h3>For you to complete</h3>

<h4>&#39;Stop at 17&#39;</h4>

<p>Write a strategy called <code>stop-at-17</code>
It should hit for as long as the hand is worth (strictly) less than 17</p>

<h4>Test strategies</h4>

<p>Write a procedure that takes a <code>player-strategy</code> a <code>house-strategy</code> and a number <code>n</code> of games to play and returns how many the player won that lets you know what fraction of the games was won by the player</p>

<p>(when I did it <code>(test-strategy stop-at-17 stop-at-17 100000)</code> was about 0.41)</p>

<h4>&#39;Stop at n&#39;</h4>

<p>Write a procedure called <code>stop-at-n</code> that takes a number and returns a strategy that will stop when it gets higher than that number (so <code>stop-at-17</code> should be &#39;the same&#39; as <code>(stop-at-n 17)</code>)</p>

<h4>&#39;Watched&#39;</h4>

<p>Write a procedure called <code>watched</code> that takes a strategy and returns a strategy that behaves the same way only also prints (as a side-effect) the arguments it was called with (hand and up-card) and the decision to hit or not</p>

<h4>Taking into account the dealers hand</h4>

<p>Take a look at <a href="https://en.wikipedia.org/wiki/Blackjack#Basic_strategy">Basic Strategy</a> in the Wikipedia Article</p>

<p>You can see that if we take into account the dealers hand that you should stop at 13 if their card is 6 or less, write a strategy that does this (maybe you can use other strategies you have created)</p>

<h4>Majority</h4>

<p>Write a procedure that takes a list of strategies and hits if a majority say they should hit. (think about what to do if the size of the list is even and there is a tie)</p>

<h4>Just one more</h4>

<p>Write a procedure that takes a strategy and returns a strategy that always stops one card later than the original</p>

</div>
<script src='https://cdn.polyfill.io/v1/polyfill.min.js'></script>
<script src="/sicpdistilled/javascripts/all-0c20c227.js"></script>
</body>
