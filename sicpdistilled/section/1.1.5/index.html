<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8'>
<meta content='IE=edge,chrome=1' http-equiv='X-UA-Compatible'>
<meta content='width=device-width, initial-scale=1' name='viewport'>
<title>SICP Distilled</title>
<link href='http://fonts.googleapis.com/css?family=Droid+Serif' rel='stylesheet' type='text/css'>
<link href="/sicpdistilled/stylesheets/all-e81cfb05.css" rel="stylesheet" />
<script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
<script type='text/x-mathjax-config'>
MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>
</head>
</html>
<body>
<div class='menu--mobile js-mobile-nav' data-target='menu'>Menu</div>
<div class='menu'>
<a href="/sicpdistilled/"><img alt="SICP Distilled" class="logo" src="/sicpdistilled/images/sicp2-07ad7dbe.jpg" />
</a><h1 class='menu__title done'>
<a href="/sicpdistilled/">SICP Distilled
</a></h1>
<ul class='menu__list'>
<li class='done'>
<a href="/sicpdistilled/section/licence"><img alt="CC by-sa" style="border-width: 0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" />
License
</a></li>
<li class='done'>
<a href="#{http_prefix}/section/donate"><img alt="MSF" width="88px" src="/sicpdistilled/images/msf-b09b7038.jpg" />
Donate
</a></li>
</ul>
<h2>Ch1 - Building Abstractions With Functions</h2>
<ul class='menu__list'>
<li class='done'>
<a href="/sicpdistilled/section/1-distilled">Chapter 1 Distilled
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1-intro">Introduction
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1">1.1 - The Elements Of Programming
</a></li>
<ul class='menu__list_2'>
<li class='done'>
<a href="/sicpdistilled/section/1.1.1">Expressions
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.2">Naming and the Environment
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.3">Evaluating Combinations
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.4">Defining New Functions
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.5">The Substitution Model
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1-exercises">Exercises
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.6a">Predicates
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.6b">Conditional Expressions
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.7">Example: Newton’s Method
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.8">Functions as Black-Box Abstractions
</a></li>
</ul>
<li class='done'>
<a href="/sicpdistilled/section/1.2">1.2 - Procedures and the Processes They Generate
</a></li>
<ul class='menu__list_2'>
<li class='done'>
<a href="/sicpdistilled/section/1.2.1">Linear Recursion and Iteration
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.2.2">Tree Recursion
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.2.3">Orders of Growth
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.2.4">Exponentiation
</a></li>
<il class='done'>
<a href="/sicpdistilled/section/1.2.5">Greatest Common Divisors
</a></il>
<li class='done'>
<a href="/sicpdistilled/section/1.2.6">Example: Testing For Primality
</a></li>
</ul>
<li class='done'>
<a href="/sicpdistilled/section/1.3-higher-order">1.3 Higher Order Functions
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/project-blackjack">Project - Blackjack
</a></li>
</ul>
<h2>Ch2 - Building Abstractions With Data</h2>
<ul class='menu__list'>
<li class='done'>
<a href="/sicpdistilled/section/2-distilled">Chapter 2 Distilled
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/2-intro">Introduction
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/2-data-abstraction">Data Abstraction
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/2-nothing">Everything From Nothing
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/2-abstractions">Abstractions In Clojure
</a></li>
<li>
<a href="/sicpdistilled/section/2-data-structures">Clojure's Data Structures
</a></li>
<li>
<a href="/sicpdistilled/section/2-data-abstraction-clj">Data Abstraction, Revisited
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/2-escher">Escher
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/project-escher">Project - Escher
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/2-symbolic">Symbolic Data
</a></li>
<li>
<a href="/sicpdistilled/section/2-sets">Representing Sets
</a></li>
<li>
<a href="/sicpdistilled/section/2-escher">Huffman Encoding Trees
</a></li>
<li>
<a href="/sicpdistilled/section/2-zippers">Zippers
</a></li>
</ul>
<h2>Ch3 - Modularity, Objects, and State</h2>
<h2>Ch4 - Metalinguistic Abstraction</h2>
<ul class='menu__list'>
<li class='done'>
<a href="/sicpdistilled/section/4.1">4.1 - The Metacircular Evaluator
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/halting">The Halting Problem
</a></li>
<li>
<a href="/sicpdistilled/section/y">The Y Combinator
</a></li>
<li>
<a href="/sicpdistilled/section/4.2">4.2 - Lazy Evaluation
</a></li>
<li>
<a href="/sicpdistilled/section/4.3">4.3 - Nondeterministic Computing
</a></li>
<li>
<a href="/sicpdistilled/section/4.4">4.4 - Logic Programming
</a></li>
</ul>
</div>
<div class='container menu--push'>
<h1>The Substitution Model for Function Application</h1>

<p>To apply a compound procedure to arguments, evaluate the body of the
function with each formal parameter replaced by the corresponding
argument.</p>

<p>Let&#39;s say we have:</p>

<pre><code class="clojure">(defn square [x]
  (* x x))
</code></pre>

<p>Then to evaluate</p>

<pre><code>(square 5)
</code></pre>

<ul>
<li><p>Take the body of the function
<code>
(* x x)
</code></p></li>
<li><p>Replace formal parameter, <code>x</code>, with the value of the argument, <code>5</code></p></li>
</ul>

<pre><code>(* 5 5)
</code></pre>

<ul>
<li>evaluate it to get 25</li>
</ul>

<h2>A more complicated example:</h2>

<p>Given:</p>

<pre><code class="clojure">(defn f [a]
  (sum-of-squares (+ a 1) (* a 2)))

(defn sum-of-squares [x y]
  (+ (* x x) (* y y)))
</code></pre>

<p>To evaluate:</p>

<pre><code class="clojure">(f 5)
</code></pre>

<p>We first look up the body of f</p>

<pre><code>(sum-of-squares (+ a 1) (* a 2))
</code></pre>

<p>and replace the formal parameter <code>a</code> with the argument <code>5</code>, getting</p>

<pre><code>(sum-of-squares (+ 5 1) (* 5 2))
</code></pre>

<p>Now we need to evaluate <code>sum-of-squares</code> in the same way, replacing
<code>x</code> with the value of <code>(+ 5 1)</code> and replacing <code>y</code> with the value of
<code>(* 5 2)</code>, giving the following sequence of substitutions:</p>

<pre><code class="clojure">(+ (square 6) (square 10))
</code></pre>

<pre><code class="clojure">(+ (* 6 6) (* 10 10))
</code></pre>

<pre><code class="clojure">(+ 36 100)
</code></pre>

<p>Though this model gets us very far, it only works for &#39;pure&#39;
functions. The SICP text always uses the term &#39;procedure&#39; for clarity
to avoid confusing them with mathematical functions. I have referred
to things created with <code>fn</code> as functions here as the usage is pretty
common, I will refer to <em>pure functions</em> if they have this
property. See also
<a href="https://en.wikipedia.org/wiki/Referential_transparency_%28computer_science%29">Referential Transparancy</a></p>

<p>We have seen that we can add names to the global environment with
<code>def</code>, another way of describing the evaluation of (square 5) is to
evaluate the body</p>

<pre><code>(* x x)
</code></pre>

<p>in an environment where x is bound to 5. This is more like what
happens inside a real interpreter (and what gets to create and/or
update different environments is an important part of understanding a
programming language).</p>

<h2>Applicative order versus normal order</h2>

<p>According to the description of evaluation so far, the interpreter
first evaluates the operator and operands and then applies the
resulting function to the resulting arguments.</p>

<p>An alternative evaluation model would not evaluate the operands until
their values were needed.  Instead it would first substitute operand
expressions for parameters until it obtained an expression involving
only primitive operators, and would then perform the evaluation.</p>

<p>If we used this method, the evaluation of <code>(f 5)</code> would proceed
according to the sequence of substitutions:</p>

<pre><code class="clojure">(sum-of-squares (+ 5 1) (* 5 2))
</code></pre>

<pre><code class="clojure">(+ (square (+ 5 1)) (square (* 5 2)))
</code></pre>

<pre><code class="clojure">(+ (* (+ 5 1) (+ 5 1)) (* (* 5 2) (* 5 2)))
</code></pre>

<pre><code class="clojure">(+ (* 6 6) (* 10 10))
</code></pre>

<pre><code class="clojure">(+ 36 100)
</code></pre>

<p>This gives the same answer as our previous evaluation model, but the
process is different. In particular, the evaluations of <code>(+ 5 1)</code> and
<code>(* 5 2)</code> are each performed twice here.</p>

<p>This alternative “fully expand and then reduce” evaluation method is
known as <em>normal-order evaluation</em>, in contrast to the “evaluate the
arguments and then apply” method that the interpreter actually uses,
which is called <em>applicative-order evaluation</em>.</p>

<p>It can be shown that, for function applications that can be modeled
using substitution (including all the functions in the first two
chapters of this book) and that yield legitimate values, normal-order
and applicative-order evaluation produce the same value.</p>

<p>Lisps usually use applicative-order evaluation, partly because of the
additional efficiency obtained from avoiding multiple evaluations of
expressions such as those illustrated with <code>(+ 5 1)</code> and <code>(* 5 2)</code>
above and, more significantly, because normal-order evaluation becomes
much more complicated to deal with when we leave the realm of
functions that can be modelled by substitution.</p>

</div>
<script src='https://cdn.polyfill.io/v1/polyfill.min.js'></script>
<script src="/sicpdistilled/javascripts/all-0c20c227.js"></script>
<link href='http://app.klipse.tech/css/codemirror.css' rel='stylesheet' type='text/css'>
<script>
  window.klipse_settings = {
    selector: 'code.clojure'
  };
</script>
<script src='http://app.klipse.tech/dev/js/klipse_plugin.js'></script>
</body>
