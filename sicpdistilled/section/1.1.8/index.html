<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8'>
<meta content='IE=edge,chrome=1' http-equiv='X-UA-Compatible'>
<meta content='width=device-width; initial-scale=1' name='viewport'>
<title>SICP Distilled</title>
<link href='http://fonts.googleapis.com/css?family=Droid+Serif' rel='stylesheet' type='text/css'>
<link href="/sicpdistilled/stylesheets/all-e81cfb05.css" rel="stylesheet" />
<script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
<script type='text/x-mathjax-config'>
MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>
</head>
</html>
<body>
<div class='menu--mobile js-mobile-nav' data-target='menu'>Menu</div>
<div class='menu'>
<a href='/'>
<img alt='SICP Distilled' class='logo' src='/sicpdistilled/images/sicp2-07ad7dbe.jpg'>
</a>
<h1 class='menu__title done'>
<a href='/'>
SICP Distilled
</a>
</h1>
<ul class='menu__list'>
<li class='done'>
<a href='/sicpdistilled/section/licence'>
<img alt='CC by-sa' src='https://i.creativecommons.org/l/by-sa/4.0/88x31.png' style='border-width:0'>
Licence
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/donate'>
<img alt='MSF ' src='/sicpdistilled/images/msf-b09b7038.jpg' style='border-width:0' width='88px'>
Donate
</a>
</li>
</ul>
<h2>Ch1 - Building Abstractions With Functions</h2>
<ul class='menu__list'>
<li class='done'>
<a href='/sicpdistilled/section/1-distilled'>
Chapter 1 Distilled
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1-intro'>
Introduction
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1'>
1.1 - The Elements Of Programming
</a>
</li>
<ul class='menu__list_2'>
<li class='done'>
<a href='/sicpdistilled/section/1.1.1'>
Expressions
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.2'>
Naming and the Environment
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.3'>
Evaluating Combinations
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.4'>
Defining New Functions
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.5'>
The Substitution Model
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1-exercises'>
Exercises
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.6a'>
Predicates
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.6b'>
Conditional Expressions
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.7'>
Example: Newton’s Method
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.1.8'>
Functions as Black-Box Abstractions
</a>
</li>
</ul>
<li class='done'>
<a href='/sicpdistilled/section/1.2'>
1.2 - Procedures and the Processes They Generate
</a>
</li>
<ul class='menu__list_2'>
<li class='done'>
<a href='/sicpdistilled/section/1.2.1'>
Linear Recursion and Iteration
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.2.2'>
Tree Recursion
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.2.3'>
Orders of Growth
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/1.2.4'>
Exponentiation
</a>
</li>
<il class='done'>
<a href='/sicpdistilled/section/1.2.5'>
Greatest Common Divisors
</a>
</il>
<li class='done'>
<a href='/sicpdistilled/section/1.2.6'>
Example: Testing For Primality
</a>
</li>
</ul>
<li class='done'>
<a href='/sicpdistilled/section/1.3-higher-order'>
1.3 Higher Order Functions
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/project-blackjack'>
Project - Blackjack
</a>
</li>
</ul>
<h2>Ch2 - Building Abstractions With Data</h2>
<ul class='menu__list'>
<li class='done'>
<a href='/sicpdistilled/section/2-distilled'>
Chapter 2 Distilled
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/2-intro'>
Introduction
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/2-data-abstraction'>
Data Abstraction
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/2-nothing'>
Everything From Nothing
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/2-abstractions'>
Abstractions In Clojure
</a>
</li>
<li>
<a href='/sicpdistilled/section/2-data-structures'>
Clojure's Data Structures
</a>
</li>
<li>
<a href='/sicpdistilled/section/2-data-abstraction-clj'>
Data Abstraction, Revisited
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/2-escher'>
Escher
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/project-escher'>
Project - Escher
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/2-symbolic'>
Symbolic Data
</a>
</li>
<li>
<a href='/sicpdistilled/section/2-sets'>
Representing Sets
</a>
</li>
<li>
<a href='/sicpdistilled/section/2-escher'>
Huffman Encoding Trees
</a>
</li>
<li>
<a href='/sicpdistilled/section/2-zippers'>
Zippers
</a>
</li>
</ul>
<h2>Ch3 - Modularity, Objects, and State</h2>
<h2>Ch4 - Metalinguistic Abstraction</h2>
<ul class='menu__list'>
<li class='done'>
<a href='/sicpdistilled/section/4.1'>
4.1 - The Metacircular Evaluator
</a>
</li>
<li class='done'>
<a href='/sicpdistilled/section/halting'>
The Halting Problem
</a>
</li>
<li>
<a href='/sicpdistilled/section/y'>
The Y Combinator
</a>
</li>
<li>
<a href='/sicpdistilled/section/4.2'>
4.2 - Lazy Evaluation
</a>
</li>
<li>
<a href='/sicpdistilled/section/4.3'>
4.3 - Nondeterministic Computing
</a>
</li>
<li>
<a href='/sicpdistilled/section/4.4'>
4.4 - Logic Programming
</a>
</li>
</ul>
</div>
<div class='container menu--push'>
<h1>Functions as Black-Box Abstractions</h1>

<p><code>sqrt</code> is our first example of a process defined by a set of mutually
defined functions. Notice that the definition of <code>sqrt-iter</code> is
<em>recursive</em> (the function is defined in terms of itself). The idea of
being able to define a function in terms of itself may be disturbing;
it may seem unclear how such a “circular” definition could make sense
at all, much less specify a well-defined process to be carried out by
a computer.</p>

<p>Observe that the problem of computing square roots breaks up naturally
into a number of subproblems: how to tell whether a guess is good
enough, how to improve a guess, and so on. Each of these tasks is
accomplished by a separate function.</p>

<p><img src="/sicpdistilled/images/1.2-8230c2c4.png" width="100%"></p>

<p>The importance of this decomposition strategy is not simply that one
is dividing the program into parts, rather, it is crucial that each
function accomplishesan identifiable task that can be used as a module
in defining other functions.</p>

<p>For example, when we define the <code>good-enough?</code> function in terms of
square , we are able to regard <code>square</code> as a “black box.”  We are not
at that moment concerned with how the function computes its
result. The details of how the square is computed can be suppressed,
to be considered at a later time. Indeed, as far as the <code>good-enough?</code>
function is concerned, <code>square</code> is not quite a function but rather an
abstraction of a function, a so-called procedural abstraction. At this
level of abstraction, any function that computes the square is equally
good.</p>

<p>Thus, considering only the values they return, the following two
functions for squaring a number should be indistinguishable. Each
takes a numerical argument and produces the square of that number as
the value.</p>

<pre><code class="clojure">(defn square [x]
  (* x x))
</code></pre>

<pre><code class="clojure">(defn (square x)
  (exp (double (log x))))

(defn double [x]
   (+ x x))
</code></pre>

<p>So a function definition should be able to suppress detail.  The users
of the function may not have written the function themselves, but may
have obtained it from another programmer. A user should not need to
know how the function is implemented in order to use it.</p>

<h2>Performance</h2>

<p>It is not even clear which of these functions is a more efficient
implementation. This depends upon the hardware available.  There are
machines for which the “obvious” implementation is the less efficient
one. Consider a machine that has extensive tables of logarithms and
antilogarithms stored in a very efficient manner.</p>

<h2>Local Names</h2>

<p>One detail of a function’s implementation that should not matter to
the user of the function is the implementer’s choice of names for the
function’s formal parameters.</p>

<p>Thus, the following functions should not be distinguishable:</p>

<pre><code>(defn square [x]
   (* x x))
</code></pre>

<pre><code>(defn square [y]
  (* y y))
</code></pre>

<p>This principle, that the meaning of a function should be independent
of the parameter names used by its author, seems on the surface to be
self-evident, but its consequences are profound. The simplest
consequence is that the parameter names of a function must be local to
the body of the function. For example, we used square in the
definition of <code>good-enough?</code> in our square-root function:</p>

<pre><code>(defn good-enough? [guess x]
  (&lt; (abs (- (square guess) x)) 0.001))
</code></pre>

<p>The intention of the author of <code>good-enough?</code> is to determine if the
square of the first argument is within a given tolerance of the second
argument. We see that the author of <code>good-enough?</code> used the name
<code>guess</code> to refer to the first argument and <code>x</code> to refer to the second
argument. The argument of <code>square</code> is <code>guess</code> . If the author of
<code>square</code> used <code>x</code> (as above) to refer to that argument, we see that
the <code>x</code> in good-enough? must be a different <code>x</code> than the one in square
.  Running the function square must not affect the value of <code>x</code> that
is used by <code>good-enough?</code> , because that value of <code>x</code> may be needed by
<code>good-enough?</code>  after <code>square</code> is done computing.</p>

<p>If the parameters were not local to the bodies of their respective
functions, then the parameter <code>x</code> in square could be confused with the
parameter <code>x</code> in <code>good-enough?</code> , and the behavior of <code>good-enough?</code>
would depend upon which version of square we used. Thus, <code>square</code>
would not be the black box we desired.</p>

<p>A formal parameter of a function has a very special role in the
function definition, in that it doesn’t matter what name the formal
parameter has. Such a name is called a <em>bound variable</em>, and we say
that the function definition binds its formal parameters. The meaning
of a function definition is unchanged if a bound variable is
consistently renamed throughout the definition.</p>

<p>If a variable is not bound, we say that it is <em>free</em>. The set of
expressions for which a binding defines a name is called the <em>scope</em>
of that name.</p>

<p>In a function definition, the bound variables declared as the formal
parameters of the function have the body of the function as their
scope.</p>

<p>In the definition of <code>good-enough?</code> above, <code>guess</code> and <code>x</code> are bound
variables but <code>&lt;</code> , <code>-</code> , <code>abs</code> , and <code>square</code> are free. The meaning
of <code>good-enough?</code> should be independent of the names we choose for
<code>guess</code> and <code>x</code> so long as they are distinct and different from <code>&lt;</code> ,
<code>-</code> , <code>abs</code> , and <code>square</code> . (If we renamed <code>guess</code> to <code>abs</code> we would
have introduced a bug by capturing the variable <code>abs</code> . It would have
changed from free to bound.)</p>

<p>The meaning of <code>good-enough?</code> is not independent of the names of its
free variables, however. It surely depends upon the fact (external to
this definition) that the symbol <code>abs</code> names a function for computing
the absolute value of a number. <code>good-enough?</code> will compute a
different function if we substitute <code>cos</code> for <code>abs</code> in its definition.</p>

<h1>TODO</h1>

<p>maybe namespaces, block structure and lexical scoping?</p>

</div>
<script src='https://cdn.polyfill.io/v1/polyfill.min.js'></script>
<script src="/sicpdistilled/javascripts/all-0c20c227.js"></script>
</body>
