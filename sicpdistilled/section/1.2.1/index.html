<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8'>
<meta content='IE=edge,chrome=1' http-equiv='X-UA-Compatible'>
<meta content='width=device-width, initial-scale=1' name='viewport'>
<title>SICP Distilled</title>
<link href='http://fonts.googleapis.com/css?family=Droid+Serif' rel='stylesheet' type='text/css'>
<link href="/sicpdistilled/stylesheets/all-e81cfb05.css" rel="stylesheet" />
<script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
<script type='text/x-mathjax-config'>
MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>
</head>
</html>
<body>
<div class='menu--mobile js-mobile-nav' data-target='menu'>Menu</div>
<div class='menu'>
<a href="/sicpdistilled/"><img alt="SICP Distilled" class="logo" src="/sicpdistilled/images/sicp2-07ad7dbe.jpg" />
</a><h1 class='menu__title done'>
<a href="/sicpdistilled/">SICP Distilled
</a></h1>
<ul class='menu__list'>
<li class='done'>
<a href="/sicpdistilled/section/licence"><img alt="CC by-sa" style="border-width: 0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" />
License
</a></li>
<li class='done'>
<a href="#{http_prefix}/section/donate"><img alt="MSF" width="88px" src="/sicpdistilled/images/msf-b09b7038.jpg" />
Donate
</a></li>
</ul>
<h2>Ch1 - Building Abstractions With Functions</h2>
<ul class='menu__list'>
<li class='done'>
<a href="/sicpdistilled/section/1-distilled">Chapter 1 Distilled
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1-intro">Introduction
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1">1.1 - The Elements Of Programming
</a></li>
<ul class='menu__list_2'>
<li class='done'>
<a href="/sicpdistilled/section/1.1.1">Expressions
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.2">Naming and the Environment
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.3">Evaluating Combinations
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.4">Defining New Functions
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.5">The Substitution Model
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1-exercises">Exercises
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.6a">Predicates
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.6b">Conditional Expressions
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.7">Example: Newton’s Method
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.1.8">Functions as Black-Box Abstractions
</a></li>
</ul>
<li class='done'>
<a href="/sicpdistilled/section/1.2">1.2 - Procedures and the Processes They Generate
</a></li>
<ul class='menu__list_2'>
<li class='done'>
<a href="/sicpdistilled/section/1.2.1">Linear Recursion and Iteration
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.2.2">Tree Recursion
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.2.3">Orders of Growth
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/1.2.4">Exponentiation
</a></li>
<il class='done'>
<a href="/sicpdistilled/section/1.2.5">Greatest Common Divisors
</a></il>
<li class='done'>
<a href="/sicpdistilled/section/1.2.6">Example: Testing For Primality
</a></li>
</ul>
<li class='done'>
<a href="/sicpdistilled/section/1.3-higher-order">1.3 Higher Order Functions
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/project-blackjack">Project - Blackjack
</a></li>
</ul>
<h2>Ch2 - Building Abstractions With Data</h2>
<ul class='menu__list'>
<li class='done'>
<a href="/sicpdistilled/section/2-distilled">Chapter 2 Distilled
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/2-intro">Introduction
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/2-data-abstraction">Data Abstraction
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/2-nothing">Everything From Nothing
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/2-abstractions">Abstractions In Clojure
</a></li>
<li>
<a href="/sicpdistilled/section/2-data-structures">Clojure's Data Structures
</a></li>
<li>
<a href="/sicpdistilled/section/2-data-abstraction-clj">Data Abstraction, Revisited
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/2-escher">Escher
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/project-escher">Project - Escher
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/2-symbolic">Symbolic Data
</a></li>
<li>
<a href="/sicpdistilled/section/2-sets">Representing Sets
</a></li>
<li>
<a href="/sicpdistilled/section/2-escher">Huffman Encoding Trees
</a></li>
<li>
<a href="/sicpdistilled/section/2-zippers">Zippers
</a></li>
</ul>
<h2>Ch3 - Modularity, Objects, and State</h2>
<h2>Ch4 - Metalinguistic Abstraction</h2>
<ul class='menu__list'>
<li class='done'>
<a href="/sicpdistilled/section/4.1">4.1 - The Metacircular Evaluator
</a></li>
<li class='done'>
<a href="/sicpdistilled/section/halting">The Halting Problem
</a></li>
<li>
<a href="/sicpdistilled/section/y">The Y Combinator
</a></li>
<li>
<a href="/sicpdistilled/section/4.2">4.2 - Lazy Evaluation
</a></li>
<li>
<a href="/sicpdistilled/section/4.3">4.3 - Nondeterministic Computing
</a></li>
<li>
<a href="/sicpdistilled/section/4.4">4.4 - Logic Programming
</a></li>
</ul>
</div>
<div class='container menu--push'>
<h1>Linear Recursion and Iteration</h1>

<p>We begin by considering the factorial function, defined by</p>

<p>$$ n! = n \cdot (n − 1) \cdot (n − 2) \dots 3 \cdot 2 \cdot 1. $$</p>

<p>There are many ways to compute factorials. One way is to make use
of the observation that $n!$ is equal to $n \cdot (n − 1)!$ for any positive
integer n:</p>

<p>$$ n! = n \cdot [(n − 1) \cdot (n − 2) \dots 3 \cdot 2 \cdot 1] = n \cdot (n − 1)! $$</p>

<p>Thus, we can compute $n!$ by computing $(n − 1)!$ and multiplying the
result by $n$. If we add the stipulation that 1! is equal to 1, this observation
translates directly into a procedure:</p>

<pre><code class="clojure">(defn factorial [n]
  (if (= n 1)
    1
    (* n (factorial (- n 1)))))
</code></pre>

<p>We can use the substitution model to watch this procedure in action computing <code>6!</code></p>

<pre><code class="clojure">(factorial 6)
</code></pre>

<pre><code class="clojure">(* 6 (factorial 5))
</code></pre>

<pre><code class="clojure">(* 6 (* 5 (factorial 4))
</code></pre>

<pre><code class="clojure">(* 6 (* 5 (* 4 (factorial 3)))
</code></pre>

<pre><code class="clojure">(* 6 (* 5 (* 4 (* 3 (factorial 2))))
</code></pre>

<pre><code class="clojure">(* 6 (* 5 (* 4 (* 3 (* 2 (factorial 1)))))
</code></pre>

<pre><code class="clojure">(* 6 (* 5 (* 4 (* 3 (* 2 1))))
</code></pre>

<pre><code class="clojure">(* 6 (* 5 (* 4 (* 3 2)))
</code></pre>

<pre><code class="clojure">(* 6 (* 5 (* 4 6))
</code></pre>

<pre><code class="clojure">(* 6 (* 5 24)
</code></pre>

<pre><code class="clojure">(* 6 120)
</code></pre>

<p>Now let’s take a different perspective on computing factorials. We
could describe a rule for computing $n!$ by specifying that we first
multiply $1$ by $2$, then multiply the result by $3$, then by $4$, and so on
until we reach $n$. More formally, we maintain a running product,
together with a counter that counts from $1$ up to $n$. We can describe
the computation by saying that the counter and the product
simultaneously change from one step to the next according to the rule</p>

<p>$$
product ← counter \cdot product
$$</p>

<p>$$
counter ← counter + 1
$$</p>

<p>and stipulating that $n!$ is the value of the product when the counter
exceeds $n$.</p>

<pre><code class="clojure">(defn factorial [n]
  (fact-iter 1 1 n))

(defn- fact-iter [product counter max-count]
  (if (&gt; counter max-count)
    product
    (fact-iter (* counter product)
               (+ counter 1)
               max-count)))
</code></pre>

<p>As before, we can use the substitution model to visualize the process of
computing <code>6!</code></p>

<pre><code class="clojure">(factorial 6)
</code></pre>

<pre><code class="clojure">(fact-iter 1 1 6)
</code></pre>

<pre><code class="clojure">(fact-iter 1 2 6)
</code></pre>

<pre><code class="clojure">(fact-iter 2 3 6)
</code></pre>

<pre><code class="clojure">(fact-iter 6 4 6)
</code></pre>

<pre><code class="clojure">(fact-iter 24 5 6)
</code></pre>

<pre><code class="clojure">(fact-iter 120 6 6)
</code></pre>

<pre><code class="clojure">(fact-iter 720 7 6)
</code></pre>

<p>Compare the two processes. From one point of view, they seem
hardly different at all. Both compute the same mathematical function on
the same domain, and each requires a number of steps proportional to n
to compute n!. Indeed, both processes even carry out the same sequence
of multiplications, obtaining the same sequence of partial products. On
the other hand, when we consider the “shapes” of the two processes, we
find that they evolve quite differently.</p>

<p>Consider the first process. The substitution model reveals a shape of
expansion followed by contraction The expansion occurs as the process
builds up a chain of deferred operations (in this case, a chain of
multiplications). The contraction occurs as the operations are
actually performed. This type of process, characterized by a chain of
deferred operations, is called a <em>recursive process</em> .  Carrying out
this process requires that the interpreter keep track of the
operations to be performed later on. In the computation of $n!$, the
length of the chain of deferred multiplications, and hence the amount
of information needed to keep track of it, grows linearly with $n$ (is
proportional to $n$), just like the number of steps. Such a process is
called a <em>linear recursive process</em>.</p>

<p>By contrast, the second process does not grow and shrink. At each
step, all we need to keep track of, for any $n$, are the current
values of the variables <code>product</code> , <code>counter</code> , and <code>max-count</code> . We
call this an <em>iterative process</em> . In general, an iterative process is
one whose state can be summarized by a fixed number of state variables
, together with a fixed rule that describes how the state variables
should be updated as the process moves from state to state and an
(optional) end test that specifies conditions under which the process
should terminate. In computing $n!$, the number of steps required grows
linearly with $n$. Such a process is called a <em>linear iterative
process</em>.</p>

<p>The contrast between the two processes can be seen in another way.  In
the iterative case, the program variables provide a complete
description of the state of the process at any point. If we stopped
the computation between steps, all we would need to do to resume the
computation is to supply the interpreter with the values of the three
program variables. Not so with the recursive process. In this case
there is some additional “hidden” information, maintained by the
interpreter and not contained in the program variables, which
indicates “where the process is” in negotiating the chain of deferred
operations. The longer the chain, the more information must be
maintained.</p>

<p>In contrasting iteration and recursion, we must be careful not to
confuse the notion of a recursive process with the notion of a
recursive function . When we describe a function as recursive, we are
referring to the syntactic fact that the function definition refers
(either directly or indirectly) to the function itself. But when we
describe a process as following a pattern that is, say, linearly
recursive, we are speaking about how the process evolves, not about
the syntax of how a function is written. It may seem disturbing that
we refer to a recursive function such as <code>fact-iter</code> as generating an
iterative process. However, the process really is iterative: Its state
is captured completely by its three state variables, and an
interpreter need keep track of only three variables in order to
execute the process.</p>

<p>One reason that the distinction between process and procedure may be
confusing is that most implementations of common languages (including
Ada, Pascal, and C) are designed in such a way that the interpretation
of any recursive procedure consumes an amount of memory that grows
with the number of procedure calls, even when the process described
is, in principle, iterative. As a consequence, these languages can
describe iterative processes only by resorting to special-purpose
“looping constructs” such as do , repeat , until , for , and while
.</p>

<p>The implementation of a Lisp we shall build in Chapter 5 does not
share this defect. It will execute an iterative process in constant
space, even if the iterative process is described by a recursive
procedure. An implementation with this property is called
<em>tail-recursive</em> . With a tail-recursive implementation, iteration can
be expressed using the ordinary procedure call mechanism, so that
special iteration constructs are useful only as syntactic sugar</p>

<h2>Exercise 1.9:</h2>

<p>Each of the following two procedures defines
a method for adding two positive integers in terms of the
procedures inc , which increments its argument by 1, and
dec , which decrements its argument by 1.</p>

<pre><code class="clojure">(defn + [a b]
  (if (= a 0) b (inc (+ (dec a) b))))
</code></pre>

<pre><code class="clojure">(defn + [a b]
  (if (= a 0) b (+ (dec a) (inc b))))
</code></pre>

<p>Using the substitution model, illustrate the process generated by each
procedure in evaluating <code>(+ 4 5)</code></p>

<p>Are these processes iterative or recursive?</p>

<h2>Exercise 1.10: The following procedure computes a mathematical</h2>

<p>function called Ackermann’s function.</p>

<pre><code class="clojure">(defn A [x y]
  (cond (= y 0) 0
  (= x 0) (* 2 y)
  (= y 1) 2
  :else (A (- x 1) (A x (- y 1)))))
</code></pre>

<p>What are the values of the following expressions?
(A 1 10)
(A 2 4)
(A 3 3)</p>

<p>Consider the following procedures, where A is the procedure defined above:</p>

<pre><code class="clojure">(def (f n) (A 0 n))
(def (g n) (A 1 n))
(def (h n) (A 2 n))
(def (k n) (* 5 n n))
</code></pre>

<p>Give concise mathematical definitions for the functions computed by
the procedures <code>f</code> , <code>g</code> , and <code>h</code> for positive integer values of
<code>n</code>. For example, <code>(k n)</code> computes $5n^2$.</p>

</div>
<script src='https://cdn.polyfill.io/v1/polyfill.min.js'></script>
<script src="/sicpdistilled/javascripts/all-0c20c227.js"></script>
<link href='http://app.klipse.tech/css/codemirror.css' rel='stylesheet' type='text/css'>
<script>
  window.klipse_settings = {
    selector: 'code.clojure'
  };
</script>
<script src='http://app.klipse.tech/dev/js/klipse_plugin.js'></script>
</body>
